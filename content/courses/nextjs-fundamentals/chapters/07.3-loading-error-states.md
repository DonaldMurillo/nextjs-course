# Chapter 7.3: Loading & Error States

## Overview

When fetching data, things take time and sometimes fail. Next.js provides built-in conventions for handling loading states (`loading.tsx`) and errors (`error.tsx`), plus streaming with Suspense for granular control.

## loading.tsx

Create a `loading.tsx` file to show a loading UI while the page loads:

```
app/
└── dashboard/
    ├── loading.tsx    ← Shows while page.tsx loads
    └── page.tsx
```

```tsx
// app/dashboard/loading.tsx
export default function Loading() {
  return <div className="loading">Loading dashboard...</div>;
}
```

### How It Works

Next.js wraps your page in a React Suspense boundary:

```tsx
// What Next.js does internally
<Suspense fallback={<Loading />}>
  <Page />
</Suspense>
```

The loading UI shows instantly while the async page component fetches data.

### Skeleton Loading

Create a better UX with skeletons that match your page layout:

```tsx
// app/dashboard/loading.tsx
export default function DashboardLoading() {
  return (
    <div className="dashboard">
      <div className="skeleton-header" />
      <div className="stats-grid">
        <div className="skeleton-card" />
        <div className="skeleton-card" />
        <div className="skeleton-card" />
      </div>
      <div className="skeleton-chart" />
    </div>
  );
}
```

```css
/* Skeleton styles */
.skeleton-header,
.skeleton-card,
.skeleton-chart {
  background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);
  background-size: 200% 100%;
  animation: shimmer 1.5s infinite;
  border-radius: 4px;
}

.skeleton-header { height: 40px; width: 200px; }
.skeleton-card { height: 100px; }
.skeleton-chart { height: 300px; }

@keyframes shimmer {
  0% { background-position: 200% 0; }
  100% { background-position: -200% 0; }
}
```

## error.tsx

Handle errors with `error.tsx`. It catches errors in the page and its children.

```tsx
// app/dashboard/error.tsx
'use client';  // Must be a Client Component

export default function DashboardError({ error, reset }) {
  return (
    <div className="error">
      <h2>Something went wrong!</h2>
      <p>{error.message}</p>
      <button onClick={() => reset()}>Try again</button>
    </div>
  );
}
```

### Error Props

- `error`: The error object that was thrown
- `reset`: Function to retry rendering the segment

### Logging Errors

```tsx
// app/dashboard/error.tsx
'use client';

import { useEffect } from 'react';

export default function DashboardError({ error, reset }) {
  useEffect(() => {
    // Log to error reporting service
    console.error('Dashboard error:', error);
    // logErrorToService(error);
  }, [error]);
  
  return (
    <div className="error">
      <h2>Failed to load dashboard</h2>
      <button onClick={reset}>Retry</button>
    </div>
  );
}
```

### Error Boundaries Don't Catch

`error.tsx` doesn't catch:
- Errors in the same segment's `layout.tsx` (use parent's error.tsx)
- Errors in root layout (use `global-error.tsx`)
- Errors in server-side redirect

### global-error.tsx

For root layout errors:

```tsx
// app/global-error.tsx
'use client';

export default function GlobalError({ error, reset }) {
  return (
    <html>
      <body>
        <h2>Something went wrong!</h2>
        <button onClick={() => reset()}>Try again</button>
      </body>
    </html>
  );
}
```

## not-found.tsx

Handle 404 errors:

```tsx
// app/not-found.tsx
import Link from 'next/link';

export default function NotFound() {
  return (
    <div className="not-found">
      <h2>Page Not Found</h2>
      <p>Could not find the requested resource.</p>
      <Link href="/">Return Home</Link>
    </div>
  );
}
```

### Triggering Not Found

```tsx
import { notFound } from 'next/navigation';

export default async function ProductPage({ params }) {
  const { id } = await params;
  const product = await getProduct(id);
  
  if (!product) {
    notFound();  // Renders not-found.tsx
  }
  
  return <ProductDetails product={product} />;
}
```

## Streaming with Suspense

For more granular loading states, use Suspense directly:

```tsx
// app/dashboard/page.tsx
import { Suspense } from 'react';

export default function Dashboard() {
  return (
    <div className="dashboard">
      <h1>Dashboard</h1>
      
      {/* Stats load independently */}
      <Suspense fallback={<StatsSkeleton />}>
        <Stats />
      </Suspense>
      
      {/* Chart loads independently */}
      <Suspense fallback={<ChartSkeleton />}>
        <RevenueChart />
      </Suspense>
      
      {/* Activity loads independently */}
      <Suspense fallback={<ActivitySkeleton />}>
        <RecentActivity />
      </Suspense>
    </div>
  );
}

// Each component fetches its own data
async function Stats() {
  const stats = await getStats();  // Takes 500ms
  return <StatsGrid stats={stats} />;
}

async function RevenueChart() {
  const data = await getRevenueData();  // Takes 1000ms
  return <Chart data={data} />;
}

async function RecentActivity() {
  const activity = await getActivity();  // Takes 300ms
  return <ActivityList items={activity} />;
}
```

### Benefits of Streaming

1. **Progressive Loading**: Fast components show first
2. **No Waterfalls**: Components load in parallel
3. **Better UX**: Users see content as it becomes available
4. **Interactivity**: Loaded sections become interactive immediately

### Streaming Order

```
Request → Header (instant) → Stats (300ms) → Activity (500ms) → Chart (1000ms)
                             ↓                ↓                  ↓
User sees:                  Stats appear    Activity appears   Chart appears
```

## Examples

### Basic Example: Simple Loading State

```tsx
// app/posts/loading.tsx
export default function PostsLoading() {
  return (
    <div className="posts-loading">
      <div className="spinner" />
      <p>Loading posts...</p>
    </div>
  );
}

// app/posts/page.tsx
export default async function PostsPage() {
  const posts = await getPosts();  // loading.tsx shows while this runs
  return <PostList posts={posts} />;
}
```

### Normal Example: Error Recovery

```tsx
// app/products/error.tsx
'use client';

import { useEffect, useState } from 'react';

export default function ProductsError({ error, reset }) {
  const [retryCount, setRetryCount] = useState(0);
  
  useEffect(() => {
    // Log error with context
    console.error('Products fetch failed:', {
      message: error.message,
      retryCount,
      timestamp: new Date().toISOString(),
    });
  }, [error, retryCount]);
  
  const handleRetry = () => {
    setRetryCount(c => c + 1);
    reset();
  };
  
  return (
    <div className="error-container">
      <h2>Failed to load products</h2>
      <p className="error-message">{error.message}</p>
      
      {retryCount < 3 ? (
        <button onClick={handleRetry}>
          Try again {retryCount > 0 && `(${retryCount}/3)`}
        </button>
      ) : (
        <div>
          <p>Multiple attempts failed. Please try:</p>
          <ul>
            <li>Refreshing the page</li>
            <li>Checking your internet connection</li>
            <li>Trying again later</li>
          </ul>
        </div>
      )}
    </div>
  );
}
```

### Complex Example: Streaming Dashboard

```tsx
// app/dashboard/page.tsx
import { Suspense } from 'react';

// Skeleton components
function CardSkeleton() {
  return <div className="card skeleton" style={{ height: 100 }} />;
}

function ChartSkeleton() {
  return <div className="chart skeleton" style={{ height: 300 }} />;
}

function TableSkeleton() {
  return (
    <div className="table skeleton">
      {[...Array(5)].map((_, i) => (
        <div key={i} className="table-row skeleton" />
      ))}
    </div>
  );
}

// Async components that fetch their own data
async function QuickStats() {
  const stats = await fetch('https://api.example.com/stats', {
    next: { revalidate: 60 }
  }).then(r => r.json());
  
  return (
    <div className="stats-grid">
      <div className="stat-card">
        <h3>Revenue</h3>
        <p>${stats.revenue.toLocaleString()}</p>
      </div>
      <div className="stat-card">
        <h3>Orders</h3>
        <p>{stats.orders}</p>
      </div>
      <div className="stat-card">
        <h3>Customers</h3>
        <p>{stats.customers}</p>
      </div>
    </div>
  );
}

async function RevenueChart() {
  // Simulate slow API
  const data = await fetch('https://api.example.com/revenue-chart', {
    next: { revalidate: 3600 }
  }).then(r => r.json());
  
  return (
    <div className="chart-container">
      <h2>Revenue Over Time</h2>
      <Chart data={data} />
    </div>
  );
}

async function RecentOrders() {
  const orders = await fetch('https://api.example.com/recent-orders', {
    cache: 'no-store'  // Always fresh
  }).then(r => r.json());
  
  return (
    <div className="orders-table">
      <h2>Recent Orders</h2>
      <table>
        <thead>
          <tr>
            <th>Order ID</th>
            <th>Customer</th>
            <th>Amount</th>
            <th>Status</th>
          </tr>
        </thead>
        <tbody>
          {orders.map(order => (
            <tr key={order.id}>
              <td>{order.id}</td>
              <td>{order.customer}</td>
              <td>${order.amount}</td>
              <td>{order.status}</td>
            </tr>
          ))}
        </tbody>
      </table>
    </div>
  );
}

// Main page component
export default function DashboardPage() {
  return (
    <div className="dashboard">
      <h1>Dashboard</h1>
      
      {/* Stats section - loads first (fastest) */}
      <section className="stats-section">
        <Suspense fallback={
          <div className="stats-grid">
            <CardSkeleton />
            <CardSkeleton />
            <CardSkeleton />
          </div>
        }>
          <QuickStats />
        </Suspense>
      </section>
      
      <div className="dashboard-grid">
        {/* Chart section - loads slower */}
        <section className="chart-section">
          <Suspense fallback={<ChartSkeleton />}>
            <RevenueChart />
          </Suspense>
        </section>
        
        {/* Orders section - always fresh, may be slower */}
        <section className="orders-section">
          <Suspense fallback={<TableSkeleton />}>
            <RecentOrders />
          </Suspense>
        </section>
      </div>
    </div>
  );
}
```

### Edge Case Example: Handling Partial Failures

```tsx
// app/dashboard/page.tsx
import { Suspense } from 'react';
import { ErrorBoundary } from 'react-error-boundary';

function SectionError({ error, resetErrorBoundary }) {
  return (
    <div className="section-error">
      <p>Failed to load this section</p>
      <button onClick={resetErrorBoundary}>Retry</button>
    </div>
  );
}

// Wrapper for resilient sections
function ResilientSection({ children, fallback }) {
  return (
    <ErrorBoundary FallbackComponent={SectionError}>
      <Suspense fallback={fallback}>
        {children}
      </Suspense>
    </ErrorBoundary>
  );
}

export default function Dashboard() {
  return (
    <div className="dashboard">
      <h1>Dashboard</h1>
      
      {/* Each section can fail independently */}
      <ResilientSection fallback={<StatsSkeleton />}>
        <Stats />
      </ResilientSection>
      
      <ResilientSection fallback={<ChartSkeleton />}>
        <Chart />
      </ResilientSection>
      
      <ResilientSection fallback={<ActivitySkeleton />}>
        <Activity />
      </ResilientSection>
    </div>
  );
}

// If Stats fails, only Stats shows error
// Chart and Activity continue to load/display
```

## Best Practices

### 1. Match Skeleton to Content

```tsx
// ✅ Good: Skeleton matches layout
function PostSkeleton() {
  return (
    <article className="post">
      <div className="skeleton title" />
      <div className="skeleton meta" />
      <div className="skeleton body" />
      <div className="skeleton body" />
    </article>
  );
}

// ❌ Bad: Generic spinner doesn't indicate what's loading
function PostLoading() {
  return <Spinner />;
}
```

### 2. Use Granular Suspense Boundaries

```tsx
// ✅ Good: Independent loading for each section
<Suspense fallback={<HeaderSkeleton />}>
  <Header />
</Suspense>
<Suspense fallback={<ContentSkeleton />}>
  <Content />
</Suspense>

// ❌ Bad: One boundary for everything
<Suspense fallback={<PageSkeleton />}>
  <Header />
  <Content />
  <Footer />
</Suspense>
```

### 3. Handle Errors Gracefully

```tsx
// ✅ Good: Helpful error with recovery options
function ProductError({ error, reset }) {
  return (
    <div>
      <h2>Couldn't load product</h2>
      <p>{error.message}</p>
      <button onClick={reset}>Try again</button>
      <Link href="/products">Browse other products</Link>
    </div>
  );
}

// ❌ Bad: Cryptic error
function ProductError({ error }) {
  return <p>Error: {error.message}</p>;
}
```

## Key Takeaways

- `loading.tsx` creates instant loading states using Suspense
- `error.tsx` catches and handles errors (must be Client Component)
- `not-found.tsx` handles 404 cases
- Use Suspense directly for granular streaming
- Streaming lets fast components show first
- Combine Suspense with Error Boundaries for resilient UIs
- Match skeletons to actual content layout

## Questions & Answers

### Q: When should I use loading.tsx vs Suspense?
**A:** Use `loading.tsx` for page-level loading. Use Suspense when you want different parts of a page to load independently.

### Q: Why must error.tsx be a Client Component?
**A:** Error boundaries need to catch errors during rendering, which requires client-side React features.

### Q: Can I have nested loading states?
**A:** Yes! Each route segment can have its own `loading.tsx`. Inner loading states show for nested routes.

### Q: How do I show a loading state for navigation?
**A:** Use `useTransition` or `nprogress` library for navigation loading indicators. `loading.tsx` only shows for the destination page.

### Q: Does streaming work with static pages?
**A:** Streaming is primarily for dynamic pages. Static pages are pre-rendered and served complete.

## Resources

- [Next.js: Loading UI and Streaming](https://nextjs.org/docs/app/building-your-application/routing/loading-ui-and-streaming)
- [Next.js: Error Handling](https://nextjs.org/docs/app/building-your-application/routing/error-handling)
- [React: Suspense](https://react.dev/reference/react/Suspense)

---

**Next Chapter:** [8. Server Actions & Forms](./08-server-actions-forms.md) - Learn how to handle form submissions and mutations with Server Actions.
