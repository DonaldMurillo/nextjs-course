# Chapter 11.1: Database with Prisma

## Overview

Prisma is a modern ORM (Object-Relational Mapping) that makes database operations type-safe and intuitive. This chapter covers setting up Prisma with SQLite for development and performing CRUD operations.

## Setting Up Prisma

### Installation

```bash
npm install prisma @prisma/client
npx prisma init --datasource-provider sqlite
```

This creates:
- `prisma/schema.prisma` - Your database schema
- `.env` - Environment variables

### Schema Definition

```prisma
// prisma/schema.prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

model User {
  id        String   @id @default(cuid())
  email     String   @unique
  name      String?
  posts     Post[]
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Post {
  id        String   @id @default(cuid())
  title     String
  content   String?
  published Boolean  @default(false)
  author    User     @relation(fields: [authorId], references: [id])
  authorId  String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}
```

### Environment Configuration

```env
# .env
DATABASE_URL="file:./dev.db"
```

### Generate Client and Migrate

```bash
# Create database and apply schema
npx prisma migrate dev --name init

# Generate Prisma Client
npx prisma generate
```

## Prisma Client Setup

Create a reusable client instance:

```ts
// lib/prisma.ts
import { PrismaClient } from '@prisma/client';

const globalForPrisma = globalThis;

export const prisma = globalForPrisma.prisma ?? new PrismaClient();

if (process.env.NODE_ENV !== 'production') {
  globalForPrisma.prisma = prisma;
}
```

This prevents creating multiple Prisma Client instances during development hot reloading.

## CRUD Operations

### Create

```ts
// Create a single record
const user = await prisma.user.create({
  data: {
    email: 'alice@example.com',
    name: 'Alice',
  },
});

// Create with relations
const post = await prisma.post.create({
  data: {
    title: 'Hello World',
    content: 'My first post',
    author: {
      connect: { id: userId },
    },
  },
});

// Create many
const users = await prisma.user.createMany({
  data: [
    { email: 'bob@example.com', name: 'Bob' },
    { email: 'charlie@example.com', name: 'Charlie' },
  ],
});
```

### Read

```ts
// Find unique (by unique field)
const user = await prisma.user.findUnique({
  where: { email: 'alice@example.com' },
});

// Find first (by any field)
const post = await prisma.post.findFirst({
  where: { published: true },
});

// Find many
const users = await prisma.user.findMany();

// With filtering
const publishedPosts = await prisma.post.findMany({
  where: { published: true },
});

// With sorting
const latestPosts = await prisma.post.findMany({
  orderBy: { createdAt: 'desc' },
});

// With pagination
const paginatedPosts = await prisma.post.findMany({
  skip: 0,
  take: 10,
});

// With relations
const userWithPosts = await prisma.user.findUnique({
  where: { id: userId },
  include: { posts: true },
});

// Select specific fields
const emails = await prisma.user.findMany({
  select: { email: true },
});
```

### Update

```ts
// Update single record
const user = await prisma.user.update({
  where: { id: userId },
  data: { name: 'New Name' },
});

// Update many
const result = await prisma.post.updateMany({
  where: { authorId: userId },
  data: { published: false },
});

// Upsert (update or create)
const user = await prisma.user.upsert({
  where: { email: 'alice@example.com' },
  update: { name: 'Alice Updated' },
  create: { email: 'alice@example.com', name: 'Alice' },
});
```

### Delete

```ts
// Delete single record
await prisma.user.delete({
  where: { id: userId },
});

// Delete many
await prisma.post.deleteMany({
  where: { published: false },
});
```

## Using in Next.js

### In Server Components

```tsx
// app/users/page.tsx
import { prisma } from '@/lib/prisma';

export default async function UsersPage() {
  const users = await prisma.user.findMany({
    include: { posts: true },
  });
  
  return (
    <ul>
      {users.map(user => (
        <li key={user.id}>
          {user.name} ({user.posts.length} posts)
        </li>
      ))}
    </ul>
  );
}
```

### In Server Actions

```ts
// app/actions.ts
'use server';

import { prisma } from '@/lib/prisma';
import { revalidatePath } from 'next/cache';

export async function createPost(formData) {
  const title = formData.get('title');
  const content = formData.get('content');
  
  await prisma.post.create({
    data: {
      title,
      content,
      authorId: 'current-user-id', // Get from session
    },
  });
  
  revalidatePath('/posts');
}

export async function deletePost(postId) {
  await prisma.post.delete({
    where: { id: postId },
  });
  
  revalidatePath('/posts');
}
```

### In Route Handlers

```tsx
// app/api/posts/route.ts
import { prisma } from '@/lib/prisma';
import { NextResponse } from 'next/server';

export async function GET() {
  const posts = await prisma.post.findMany({
    include: { author: true },
    orderBy: { createdAt: 'desc' },
  });
  
  return NextResponse.json(posts);
}

export async function POST(request) {
  const body = await request.json();
  
  const post = await prisma.post.create({
    data: body,
  });
  
  return NextResponse.json(post, { status: 201 });
}
```

## Examples

### Basic Example: Simple Blog

```prisma
// prisma/schema.prisma
model Post {
  id        String   @id @default(cuid())
  slug      String   @unique
  title     String
  content   String
  published Boolean  @default(false)
  createdAt DateTime @default(now())
}
```

```tsx
// app/blog/page.tsx
import { prisma } from '@/lib/prisma';
import Link from 'next/link';

export default async function BlogPage() {
  const posts = await prisma.post.findMany({
    where: { published: true },
    orderBy: { createdAt: 'desc' },
  });
  
  return (
    <div>
      <h1>Blog</h1>
      {posts.map(post => (
        <article key={post.id}>
          <Link href={`/blog/${post.slug}`}>
            <h2>{post.title}</h2>
          </Link>
          <time>{post.createdAt.toLocaleDateString()}</time>
        </article>
      ))}
    </div>
  );
}

// app/blog/[slug]/page.tsx
import { prisma } from '@/lib/prisma';
import { notFound } from 'next/navigation';

export default async function PostPage({ params }) {
  const { slug } = await params;
  
  const post = await prisma.post.findUnique({
    where: { slug, published: true },
  });
  
  if (!post) notFound();
  
  return (
    <article>
      <h1>{post.title}</h1>
      <p>{post.content}</p>
    </article>
  );
}
```

### Normal Example: User Posts with Relations

```prisma
// prisma/schema.prisma
model User {
  id    String @id @default(cuid())
  email String @unique
  name  String
  posts Post[]
}

model Post {
  id       String @id @default(cuid())
  title    String
  author   User   @relation(fields: [authorId], references: [id])
  authorId String
}
```

```tsx
// app/users/[id]/posts/page.tsx
import { prisma } from '@/lib/prisma';
import { notFound } from 'next/navigation';

export default async function UserPostsPage({ params }) {
  const { id } = await params;
  
  const user = await prisma.user.findUnique({
    where: { id },
    include: {
      posts: {
        orderBy: { createdAt: 'desc' },
      },
    },
  });
  
  if (!user) notFound();
  
  return (
    <div>
      <h1>Posts by {user.name}</h1>
      {user.posts.length === 0 ? (
        <p>No posts yet.</p>
      ) : (
        <ul>
          {user.posts.map(post => (
            <li key={post.id}>{post.title}</li>
          ))}
        </ul>
      )}
    </div>
  );
}
```

## Prisma Studio

Prisma includes a GUI for viewing and editing data:

```bash
npx prisma studio
```

Opens at `http://localhost:5555`

## Migrations

```bash
# Create migration
npx prisma migrate dev --name add_category

# Apply migrations in production
npx prisma migrate deploy

# Reset database (development only)
npx prisma migrate reset
```

## Key Takeaways

- Prisma provides type-safe database access
- Define models in `schema.prisma`
- Use a singleton pattern for the Prisma Client
- Prisma works seamlessly with Server Components and Server Actions
- Use `include` for relations, `select` for specific fields
- Migrations manage schema changes

## Questions & Answers

### Q: Why use a singleton for Prisma Client?
**A:** In development, hot reloading would create new connections each time. The singleton pattern reuses the existing connection.

### Q: How do I switch to PostgreSQL for production?
**A:** Change the provider in `schema.prisma` and update `DATABASE_URL`:
```prisma
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}
```

### Q: How do I seed the database?
**A:** Create `prisma/seed.js` and add to `package.json`:
```json
"prisma": { "seed": "node prisma/seed.js" }
```
Run with `npx prisma db seed`.

## Resources

- [Prisma Documentation](https://www.prisma.io/docs)
- [Prisma with Next.js](https://www.prisma.io/nextjs)
- [Prisma Schema Reference](https://www.prisma.io/docs/reference/api-reference/prisma-schema-reference)

---

**Next Chapter:** [12. Authentication Patterns](./12-authentication-patterns.md) - Learn how to implement authentication in Next.js.
