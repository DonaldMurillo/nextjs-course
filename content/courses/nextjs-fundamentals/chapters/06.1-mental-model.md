# Chapter 6.1: The Mental Model

## Overview

Understanding the mental model behind Server and Client Components is crucial for building efficient Next.js applications. This chapter explains how they work, when they render, and how data flows between them.

## The Render Lifecycle

### Server Components

Server Components render once on the server. Here's the flow:

```
1. Request comes in
2. Server Component executes (can be async)
3. Data is fetched directly (database, APIs, file system)
4. Component returns JSX
5. JSX is converted to HTML
6. HTML is sent to browser
7. Browser displays content immediately
```

No JavaScript is sent for Server Components - just HTML.

### Client Components

Client Components render on server first (for HTML), then hydrate in browser:

```
1. Request comes in
2. Client Component renders on server (initial HTML)
3. HTML + Component JavaScript sent to browser
4. Browser displays HTML immediately
5. JavaScript loads and "hydrates" the HTML
6. Component becomes interactive
```

## The "use client" Boundary

The `"use client"` directive creates a boundary. Everything in that file and its imports becomes part of the client bundle.

```tsx
// components/InteractiveWidget.tsx
"use client";  // ← This file and its imports are client-side

import { useState } from 'react';
import { formatDate } from '@/lib/utils';  // ← This gets bundled too!

export function InteractiveWidget() {
  const [count, setCount] = useState(0);
  return <button onClick={() => setCount(count + 1)}>{count}</button>;
}
```

### The Boundary is "Infectious"

```tsx
// ❌ Problem: Importing a client component makes this module client-side
"use client";

import { HeavyLibrary } from 'heavy-library';  // Now in client bundle!
```

### Solution: Move Imports Up

```tsx
// app/page.tsx (Server Component)
import { HeavyLibrary } from 'heavy-library';  // Server-side only
import { InteractiveWidget } from '@/components/InteractiveWidget';

export default function Page() {
  const data = HeavyLibrary.process();  // Runs on server
  return <InteractiveWidget initialData={data} />;
}
```

## Data Flow Between Components

### Server → Client: Props Must Be Serializable

Data passed from Server to Client Components must be JSON-serializable:

```tsx
// ✅ Serializable - these work
<ClientComponent
  string="hello"
  number={42}
  boolean={true}
  array={[1, 2, 3]}
  object={{ key: 'value' }}
  null={null}
/>

// ❌ Not serializable - these fail
<ClientComponent
  function={() => console.log('hi')}
  date={new Date()}
  map={new Map()}
  set={new Set()}
  class={new MyClass()}
/>
```

### Converting Non-Serializable Data

```tsx
// Server Component
export default async function Page() {
  const date = new Date();
  const user = await getUser();

  return (
    <ClientComponent
      // Convert Date to string
      dateString={date.toISOString()}
      // Extract only needed, serializable data
      userName={user.name}
      userEmail={user.email}
    />
  );
}
```

### Client → Server: Server Actions

Client Components can call Server Actions to send data back:

```tsx
// app/actions.ts
'use server';

export async function submitForm(data: FormData) {
  const name = data.get('name');
  await db.users.create({ data: { name } });
}
```

```tsx
// components/Form.tsx
'use client';

import { submitForm } from '@/app/actions';

export function Form() {
  return (
    <form action={submitForm}>
      <input name="name" />
      <button type="submit">Submit</button>
    </form>
  );
}
```

## Component Composition Patterns

### Pattern 1: Server Parent, Client Child

The most common pattern - Server Component fetches data, Client Component handles interactivity:

```tsx
// app/dashboard/page.tsx (Server Component)
import { Chart } from '@/components/Chart';

export default async function Dashboard() {
  const data = await fetchAnalytics();  // Server-side fetch

  return (
    <div>
      <h1>Dashboard</h1>
      <Chart data={data} />  {/* Client Component for interactivity */}
    </div>
  );
}
```

### Pattern 2: Client Parent, Server Children via Props

Client Components can render Server Components passed as children:

```tsx
// components/Tabs.tsx
'use client';

import { useState } from 'react';

export function Tabs({ tabs }: { tabs: { label: string; content: React.ReactNode }[] }) {
  const [activeIndex, setActiveIndex] = useState(0);

  return (
    <div>
      <div className="tab-buttons">
        {tabs.map((tab, i) => (
          <button key={i} onClick={() => setActiveIndex(i)}>
            {tab.label}
          </button>
        ))}
      </div>
      <div className="tab-content">
        {tabs[activeIndex].content}  {/* Can be Server Component! */}
      </div>
    </div>
  );
}
```

```tsx
// app/page.tsx (Server Component)
import { Tabs } from '@/components/Tabs';
import { ServerContent } from '@/components/ServerContent';

export default function Page() {
  return (
    <Tabs tabs={[
      { label: 'Tab 1', content: <ServerContent id={1} /> },
      { label: 'Tab 2', content: <ServerContent id={2} /> },
    ]} />
  );
}
```

### Pattern 3: The Children Pattern

Pass Server Components as children to avoid the client boundary:

```tsx
// components/Modal.tsx
'use client';

export function Modal({ children, isOpen, onClose }) {
  if (!isOpen) return null;

  return (
    <div className="modal-overlay" onClick={onClose}>
      <div className="modal-content" onClick={e => e.stopPropagation()}>
        {children}  {/* Server Component content works here! */}
      </div>
    </div>
  );
}
```

```tsx
// app/page.tsx (Server Component)
import { Modal } from '@/components/Modal';
import { ProductDetails } from '@/components/ProductDetails';

export default async function Page() {
  const product = await getProduct();

  return (
    <Modal>
      <ProductDetails product={product} />  {/* Server Component */}
    </Modal>
  );
}
```

## When Components Re-render

### Server Components

Server Components **don't re-render** in the traditional sense. They render:
- On initial page load
- On navigation to the route
- When `revalidatePath()` or `revalidateTag()` is called
- When cache expires

### Client Components

Client Components re-render when:
- State changes (`useState`, `useReducer`)
- Props change
- Parent re-renders
- Context changes

## Visualizing the Boundary

```
┌─────────────────────────────────────────────────┐
│                    SERVER                        │
│  ┌───────────────────────────────────────────┐  │
│  │           Server Component                 │  │
│  │  - Direct database access                  │  │
│  │  - File system access                      │  │
│  │  - Environment secrets                     │  │
│  │                                            │  │
│  │    ┌─────────────────────────────────┐    │  │
│  │    │  "use client" BOUNDARY          │    │  │
│  │    │  ─────────────────────────────  │    │  │
│  │    │                                 │    │  │
│  │    │    Client Component             │    │  │
│  │    │    - useState, useEffect        │    │  │
│  │    │    - onClick, onChange          │    │  │
│  │    │    - Browser APIs               │    │  │
│  │    │                                 │    │  │
│  │    └─────────────────────────────────┘    │  │
│  │                                            │  │
│  │           Server Component                 │  │
│  │           (can continue here)              │  │
│  └───────────────────────────────────────────┘  │
└─────────────────────────────────────────────────┘
```

## Key Takeaways

- Server Components render once on the server, sending only HTML
- Client Components render on server (HTML) then hydrate in browser
- `"use client"` creates a boundary - everything below is client-side
- Props between Server and Client must be serializable
- Use the children pattern to compose Server Components within Client Components
- Server Components don't re-render; Client Components re-render on state/prop changes

## Questions & Answers

### Q: Can a Client Component import a Server Component?
**A:** No, not directly. But a Client Component can receive Server Components as children or props (the children pattern).

### Q: What happens if I forget "use client"?
**A:** You'll get an error if you try to use hooks or browser APIs in what Next.js thinks is a Server Component.

### Q: Do Server Components have access to request data?
**A:** Yes, through functions like `cookies()`, `headers()`, and page props like `params` and `searchParams`.

### Q: Can I use React Context in Server Components?
**A:** No. Context requires client-side state. Create a Client Component provider and use the children pattern.

## Resources

- [React: Server Components](https://react.dev/reference/rsc/server-components)
- [Next.js: Server and Client Components](https://nextjs.org/docs/app/building-your-application/rendering/composition-patterns)

