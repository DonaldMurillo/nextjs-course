# Chapter 5.2: Parallel & Intercepting Routes

## Overview

Parallel and intercepting routes are advanced patterns that enable complex UI behaviors like modals, split views, and conditional rendering. These patterns are powerful but add complexity—use them when simpler solutions don't work.

## Parallel Routes

Parallel routes render multiple pages simultaneously in the same layout. They're defined using named "slots" with the `@folder` convention.

### Creating Slots

```
app/
├── layout.tsx
├── page.tsx
├── @sidebar/
│   └── page.tsx
└── @main/
    └── page.tsx
```

The layout receives each slot as a prop:

```tsx
// app/layout.tsx
export default function Layout({ children, sidebar, main }) {
  return (
    <div className="layout">
      <aside>{sidebar}</aside>
      <main>{main}</main>
      {children}
    </div>
  );
}
```

### How Slots Work

- Slots don't affect the URL structure
- Each slot can have its own loading and error states
- Slots can be conditionally rendered
- Unmatched slots render their `default.tsx` or nothing

### Dashboard Example

```
app/
└── dashboard/
    ├── layout.tsx
    ├── page.tsx
    ├── @stats/
    │   ├── page.tsx
    │   └── loading.tsx
    ├── @activity/
    │   ├── page.tsx
    │   └── loading.tsx
    └── @notifications/
        ├── page.tsx
        └── default.tsx
```

```tsx
// app/dashboard/layout.tsx
export default function DashboardLayout({ 
  children, 
  stats, 
  activity, 
  notifications 
}) {
  return (
    <div className="dashboard">
      <header className="dashboard-header">
        {notifications}
      </header>
      <div className="dashboard-grid">
        <section className="stats">{stats}</section>
        <section className="activity">{activity}</section>
      </div>
      <main>{children}</main>
    </div>
  );
}

// app/dashboard/@stats/page.tsx
async function getStats() {
  const res = await fetch('https://api.example.com/stats');
  return res.json();
}

export default async function StatsPanel() {
  const stats = await getStats();
  
  return (
    <div className="stats-panel">
      <h2>Stats</h2>
      <p>Users: {stats.users}</p>
      <p>Revenue: ${stats.revenue}</p>
    </div>
  );
}

// app/dashboard/@stats/loading.tsx
export default function StatsLoading() {
  return <div className="skeleton">Loading stats...</div>;
}
```

### The default.tsx File

When a slot doesn't match the current URL, Next.js needs to know what to render. Use `default.tsx`:

```tsx
// app/dashboard/@notifications/default.tsx
export default function DefaultNotifications() {
  return null; // Or a default UI
}
```

Without `default.tsx`, unmatched slots cause a 404.

### Conditional Slots

Render different content based on conditions:

```tsx
// app/layout.tsx
import { getUser } from '@/lib/auth';

export default async function Layout({ children, admin, user }) {
  const currentUser = await getUser();
  
  return (
    <div>
      <nav>{currentUser?.isAdmin ? admin : user}</nav>
      <main>{children}</main>
    </div>
  );
}
```

## Intercepting Routes

Intercepting routes let you load a route within the current layout while showing a different URL. The classic use case: opening a photo in a modal that shows the photo's URL, but when navigating directly to that URL, showing a full page.

### Interception Conventions

| Convention | Matches |
|------------|---------|
| `(.)` | Same level |
| `(..)` | One level up |
| `(..)(..)` | Two levels up |
| `(...)` | From root |

### Photo Modal Example

```
app/
├── layout.tsx
├── page.tsx
├── @modal/
│   ├── (.)photos/
│   │   └── [id]/
│   │       └── page.tsx    # Modal view
│   └── default.tsx
└── photos/
    └── [id]/
        └── page.tsx         # Full page view
```

**Behavior:**
1. Click photo from `/` → URL changes to `/photos/123`, modal opens
2. Navigate directly to `/photos/123` → Full page renders
3. Refresh on `/photos/123` → Full page renders

```tsx
// app/layout.tsx
export default function Layout({ children, modal }) {
  return (
    <html>
      <body>
        {children}
        {modal}
      </body>
    </html>
  );
}

// app/@modal/default.tsx
export default function Default() {
  return null;
}

// app/@modal/(.)photos/[id]/page.tsx
import { Modal } from '@/components/Modal';

export default async function PhotoModal({ params }) {
  const { id } = await params;
  const photo = await getPhoto(id);
  
  return (
    <Modal>
      <img src={photo.url} alt={photo.title} />
      <h2>{photo.title}</h2>
    </Modal>
  );
}

// app/photos/[id]/page.tsx
export default async function PhotoPage({ params }) {
  const { id } = await params;
  const photo = await getPhoto(id);
  
  return (
    <div className="photo-page">
      <img src={photo.url} alt={photo.title} />
      <h1>{photo.title}</h1>
      <p>{photo.description}</p>
    </div>
  );
}
```

### Modal Component

```tsx
// components/Modal.tsx
'use client';

import { useRouter } from 'next/navigation';

export function Modal({ children }) {
  const router = useRouter();
  
  const handleClose = () => {
    router.back();
  };
  
  return (
    <div className="modal-overlay" onClick={handleClose}>
      <div className="modal-content" onClick={e => e.stopPropagation()}>
        <button className="modal-close" onClick={handleClose}>
          ×
        </button>
        {children}
      </div>
    </div>
  );
}
```

## Examples

### Basic Example: Simple Slot

```
app/
└── dashboard/
    ├── layout.tsx
    ├── page.tsx
    └── @sidebar/
        └── page.tsx
```

```tsx
// app/dashboard/layout.tsx
export default function Layout({ children, sidebar }) {
  return (
    <div className="flex">
      <aside className="w-64">{sidebar}</aside>
      <main className="flex-1">{children}</main>
    </div>
  );
}

// app/dashboard/@sidebar/page.tsx
export default function Sidebar() {
  return (
    <nav>
      <a href="/dashboard">Overview</a>
      <a href="/dashboard/settings">Settings</a>
    </nav>
  );
}

// app/dashboard/page.tsx
export default function Dashboard() {
  return <h1>Dashboard</h1>;
}
```

### Normal Example: Auth-Gated Modal

```
app/
├── layout.tsx
├── page.tsx
├── @auth/
│   ├── (.)login/
│   │   └── page.tsx
│   └── default.tsx
└── login/
    └── page.tsx
```

```tsx
// app/layout.tsx
export default function RootLayout({ children, auth }) {
  return (
    <html>
      <body>
        {children}
        {auth}
      </body>
    </html>
  );
}

// app/page.tsx
import Link from 'next/link';

export default function Home() {
  return (
    <div>
      <h1>Welcome</h1>
      <Link href="/login">Login</Link>
    </div>
  );
}

// app/@auth/default.tsx
export default function Default() {
  return null;
}

// app/@auth/(.)login/page.tsx
'use client';

import { useRouter } from 'next/navigation';

export default function LoginModal() {
  const router = useRouter();
  
  return (
    <div className="modal-overlay">
      <div className="modal">
        <h2>Login</h2>
        <form>
          <input type="email" placeholder="Email" />
          <input type="password" placeholder="Password" />
          <button type="submit">Login</button>
        </form>
        <button onClick={() => router.back()}>Cancel</button>
      </div>
    </div>
  );
}

// app/login/page.tsx
export default function LoginPage() {
  return (
    <div className="login-page">
      <h1>Login</h1>
      <form>
        <input type="email" placeholder="Email" />
        <input type="password" placeholder="Password" />
        <button type="submit">Login</button>
      </form>
    </div>
  );
}
```

### Complex Example: Product Quick View

```
app/
├── layout.tsx
├── shop/
│   ├── layout.tsx
│   ├── page.tsx
│   ├── @quickview/
│   │   ├── (.)product/
│   │   │   └── [id]/
│   │   │       └── page.tsx
│   │   └── default.tsx
│   └── product/
│       └── [id]/
│           └── page.tsx
```

```tsx
// app/shop/layout.tsx
export default function ShopLayout({ children, quickview }) {
  return (
    <div className="shop">
      {children}
      {quickview}
    </div>
  );
}

// app/shop/page.tsx
import Link from 'next/link';

async function getProducts() {
  const res = await fetch('https://api.example.com/products');
  return res.json();
}

export default async function ShopPage() {
  const products = await getProducts();
  
  return (
    <div className="product-grid">
      {products.map(product => (
        <Link 
          key={product.id} 
          href={`/shop/product/${product.id}`}
          className="product-card"
        >
          <img src={product.image} alt={product.name} />
          <h3>{product.name}</h3>
          <p>${product.price}</p>
        </Link>
      ))}
    </div>
  );
}

// app/shop/@quickview/default.tsx
export default function Default() {
  return null;
}

// app/shop/@quickview/(.)product/[id]/page.tsx
'use client';

import { useRouter } from 'next/navigation';
import { useState, useEffect } from 'react';

export default function QuickView({ params }) {
  const router = useRouter();
  const [product, setProduct] = useState(null);
  
  useEffect(() => {
    async function load() {
      const res = await fetch(`/api/products/${params.id}`);
      setProduct(await res.json());
    }
    load();
  }, [params.id]);
  
  if (!product) return <div className="quickview-loading">Loading...</div>;
  
  return (
    <div className="quickview-overlay" onClick={() => router.back()}>
      <div className="quickview" onClick={e => e.stopPropagation()}>
        <button className="close" onClick={() => router.back()}>×</button>
        <img src={product.image} alt={product.name} />
        <h2>{product.name}</h2>
        <p className="price">${product.price}</p>
        <p>{product.shortDescription}</p>
        <div className="actions">
          <button className="add-to-cart">Add to Cart</button>
          <Link href={`/shop/product/${product.id}`}>
            View Full Details
          </Link>
        </div>
      </div>
    </div>
  );
}

// app/shop/product/[id]/page.tsx
import { notFound } from 'next/navigation';

async function getProduct(id) {
  const res = await fetch(`https://api.example.com/products/${id}`);
  if (!res.ok) return null;
  return res.json();
}

export default async function ProductPage({ params }) {
  const { id } = await params;
  const product = await getProduct(id);
  
  if (!product) notFound();
  
  return (
    <div className="product-page">
      <div className="product-gallery">
        {product.images.map(img => (
          <img key={img} src={img} alt={product.name} />
        ))}
      </div>
      <div className="product-info">
        <h1>{product.name}</h1>
        <p className="price">${product.price}</p>
        <p className="description">{product.description}</p>
        <div className="variants">
          {/* Size, color selectors */}
        </div>
        <button className="add-to-cart">Add to Cart</button>
      </div>
      <div className="product-details">
        <h2>Details</h2>
        <p>{product.details}</p>
      </div>
      <div className="reviews">
        <h2>Reviews</h2>
        {/* Reviews component */}
      </div>
    </div>
  );
}
```

### Edge Case Example: Handling Navigation States

```tsx
// components/InterceptedModal.tsx
'use client';

import { useRouter, usePathname } from 'next/navigation';
import { useEffect, useState } from 'react';

export function InterceptedModal({ children, returnPath }) {
  const router = useRouter();
  const pathname = usePathname();
  const [isClosing, setIsClosing] = useState(false);
  
  // Handle escape key
  useEffect(() => {
    const handleEscape = (e) => {
      if (e.key === 'Escape') {
        handleClose();
      }
    };
    
    document.addEventListener('keydown', handleEscape);
    return () => document.removeEventListener('keydown', handleEscape);
  }, []);
  
  // Prevent body scroll when modal is open
  useEffect(() => {
    document.body.style.overflow = 'hidden';
    return () => {
      document.body.style.overflow = 'unset';
    };
  }, []);
  
  const handleClose = () => {
    setIsClosing(true);
    
    // Animate out, then navigate
    setTimeout(() => {
      // Use replace to avoid history accumulation
      if (returnPath) {
        router.replace(returnPath);
      } else {
        router.back();
      }
    }, 200);
  };
  
  return (
    <div 
      className={`modal-overlay ${isClosing ? 'closing' : ''}`}
      onClick={handleClose}
    >
      <div 
        className={`modal-content ${isClosing ? 'closing' : ''}`}
        onClick={e => e.stopPropagation()}
        role="dialog"
        aria-modal="true"
      >
        <button 
          className="modal-close" 
          onClick={handleClose}
          aria-label="Close modal"
        >
          ×
        </button>
        {children}
      </div>
    </div>
  );
}
```

## When to Use (and When Not To)

### Use Parallel Routes When:
- You need independent loading states for different sections
- Different parts of the page need different error boundaries
- You want conditional rendering based on auth/role
- Building dashboard-style layouts with multiple data sources

### Use Intercepting Routes When:
- You want modal behavior with URL updates
- Users should be able to share modal URLs
- Direct navigation should show full page, not modal

### Avoid These Patterns When:
- A simple conditional render would work
- The complexity isn't justified by the UX improvement
- You're just trying to organize code (use route groups instead)
- State could be managed with query params or React state

## Key Takeaways

- Parallel routes (`@folder`) render multiple pages in the same layout
- Slots are passed as props to the layout component
- Use `default.tsx` to handle unmatched slots
- Intercepting routes (`(.)`, `(..)`, etc.) load routes within current layout
- Intercepted routes show full pages on direct navigation
- These patterns add complexity—use only when needed

## Questions & Answers

### Q: Can I have parallel routes without intercepting routes?
**A:** Yes, they're independent features. Parallel routes for multi-section layouts, intercepting routes for modal-style navigation.

### Q: Why is my slot showing 404?
**A:** You likely need a `default.tsx` file. Slots that don't match the current route need a default fallback.

### Q: Can I nest intercepting routes?
**A:** Yes, but it gets complex. The interception conventions stack: `(..)(..)` goes up two levels.

### Q: Do intercepted routes work with back/forward buttons?
**A:** Yes. The URL is updated, so browser history works correctly.

### Q: Can I pass data between parallel slots?
**A:** Not directly. Use a shared layout, context, or state management library.

### Q: How do I test intercepting routes?
**A:** Test both paths: clicking from a page (should intercept) and direct navigation (should show full page).

## Resources

- [Next.js: Parallel Routes](https://nextjs.org/docs/app/building-your-application/routing/parallel-routes)
- [Next.js: Intercepting Routes](https://nextjs.org/docs/app/building-your-application/routing/intercepting-routes)
- [Vercel: Modal Pattern Example](https://nextjs.org/docs/app/building-your-application/routing/intercepting-routes#modals)

---

**Next:** [5.3 Navigation](./05.3-navigation.md) - Master the Link component and programmatic navigation.
