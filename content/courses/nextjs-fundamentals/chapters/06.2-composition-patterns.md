# Chapter 6.2: Composition Patterns

## Overview

Server and Client Components are most powerful when composed together. This chapter covers patterns for mixing them effectively: passing Server Components as children, using providers, and organizing your component hierarchy.

## The Children Pattern

Client Components can receive Server Components as children. This is the most important composition pattern.

### Why It Works

When a Server Component renders a Client Component with children, the children are rendered on the server first, then passed as props:

```tsx
// app/page.tsx (Server Component)
import { ClientWrapper } from '@/components/ClientWrapper';
import { ServerContent } from '@/components/ServerContent';

export default function Page() {
  return (
    <ClientWrapper>
      <ServerContent />  {/* Rendered on server, passed as children */}
    </ClientWrapper>
  );
}
```

```tsx
// components/ClientWrapper.tsx
"use client";

export function ClientWrapper({ children }) {
  const [isExpanded, setIsExpanded] = useState(true);
  
  return (
    <div className={isExpanded ? 'expanded' : 'collapsed'}>
      <button onClick={() => setIsExpanded(!isExpanded)}>
        Toggle
      </button>
      {isExpanded && children}  {/* Server-rendered content */}
    </div>
  );
}
```

```tsx
// components/ServerContent.tsx (Server Component - no "use client")
async function getData() {
  const res = await fetch('https://api.example.com/data');
  return res.json();
}

export async function ServerContent() {
  const data = await getData();
  
  return (
    <div>
      <h2>{data.title}</h2>
      <p>{data.description}</p>
    </div>
  );
}
```

### The Key Insight

The `children` prop is already rendered by the time it reaches the Client Component. The Client Component doesn't import or execute the Server Component‚Äîit just receives its output.

```
Server renders:
  Page
    ‚îî‚îÄ ClientWrapper
         ‚îî‚îÄ ServerContent (rendered here!)

Browser receives:
  ClientWrapper({ children: <div><h2>...</h2><p>...</p></div> })
```

## Slot Props Pattern

Beyond `children`, you can pass Server Components through any prop:

```tsx
// app/page.tsx (Server Component)
import { Layout } from '@/components/Layout';
import { Header } from '@/components/Header';
import { Sidebar } from '@/components/Sidebar';
import { MainContent } from '@/components/MainContent';

export default async function Page() {
  const user = await getUser();
  
  return (
    <Layout
      header={<Header user={user} />}
      sidebar={<Sidebar />}
      main={<MainContent />}
    />
  );
}
```

```tsx
// components/Layout.tsx
"use client";

import { useState } from 'react';

export function Layout({ header, sidebar, main }) {
  const [sidebarOpen, setSidebarOpen] = useState(true);
  
  return (
    <div className="layout">
      <header>{header}</header>
      <div className="body">
        {sidebarOpen && <aside>{sidebar}</aside>}
        <main>{main}</main>
      </div>
      <button onClick={() => setSidebarOpen(!sidebarOpen)}>
        Toggle Sidebar
      </button>
    </div>
  );
}
```

## Provider Patterns

Context providers must be Client Components (they use React context). Here's how to use them without making your whole app client-side.

### Wrapping the App

```tsx
// app/layout.tsx (Server Component)
import { Providers } from '@/components/Providers';

export default function RootLayout({ children }) {
  return (
    <html>
      <body>
        <Providers>
          {children}  {/* Server Components can be children! */}
        </Providers>
      </body>
    </html>
  );
}
```

```tsx
// components/Providers.tsx
"use client";

import { ThemeProvider } from '@/contexts/theme';
import { AuthProvider } from '@/contexts/auth';
import { QueryClientProvider } from '@tanstack/react-query';

export function Providers({ children }) {
  return (
    <QueryClientProvider client={queryClient}>
      <AuthProvider>
        <ThemeProvider>
          {children}
        </ThemeProvider>
      </AuthProvider>
    </QueryClientProvider>
  );
}
```

### Providers with Server Data

Pass server-fetched data to client providers:

```tsx
// app/layout.tsx (Server Component)
import { getSession } from '@/lib/auth';
import { AuthProvider } from '@/components/AuthProvider';

export default async function RootLayout({ children }) {
  const session = await getSession();
  
  return (
    <html>
      <body>
        <AuthProvider initialSession={session}>
          {children}
        </AuthProvider>
      </body>
    </html>
  );
}
```

```tsx
// components/AuthProvider.tsx
"use client";

import { createContext, useContext, useState } from 'react';

const AuthContext = createContext(null);

export function AuthProvider({ children, initialSession }) {
  const [session, setSession] = useState(initialSession);
  
  return (
    <AuthContext.Provider value={{ session, setSession }}>
      {children}
    </AuthContext.Provider>
  );
}

export function useAuth() {
  return useContext(AuthContext);
}
```

## Component Organization

### Pattern 1: Islands of Interactivity

Keep most of your app as Server Components. Add Client Components only where needed:

```
app/
‚îî‚îÄ‚îÄ products/
    ‚îî‚îÄ‚îÄ page.tsx                    (Server - fetches products)
        ‚îú‚îÄ‚îÄ ProductList.tsx         (Server - renders list)
        ‚îÇ   ‚îî‚îÄ‚îÄ ProductCard.tsx     (Server - renders card)
        ‚îÇ       ‚îî‚îÄ‚îÄ AddToCart.tsx   (Client - button interaction)
        ‚îî‚îÄ‚îÄ FilterPanel.tsx         (Client - filter state)
```

```tsx
// app/products/page.tsx (Server)
import { ProductList } from './ProductList';
import { FilterPanel } from './FilterPanel';

export default async function ProductsPage() {
  const products = await getProducts();
  
  return (
    <div>
      <FilterPanel />
      <ProductList products={products} />
    </div>
  );
}

// components/ProductList.tsx (Server)
import { ProductCard } from './ProductCard';

export function ProductList({ products }) {
  return (
    <div className="grid">
      {products.map(product => (
        <ProductCard key={product.id} product={product} />
      ))}
    </div>
  );
}

// components/ProductCard.tsx (Server)
import { AddToCart } from './AddToCart';

export function ProductCard({ product }) {
  return (
    <div className="card">
      <img src={product.image} alt={product.name} />
      <h3>{product.name}</h3>
      <p>${product.price}</p>
      <AddToCart productId={product.id} />
    </div>
  );
}

// components/AddToCart.tsx (Client)
"use client";

import { useState } from 'react';

export function AddToCart({ productId }) {
  const [adding, setAdding] = useState(false);
  
  const handleAdd = async () => {
    setAdding(true);
    await addToCart(productId);
    setAdding(false);
  };
  
  return (
    <button onClick={handleAdd} disabled={adding}>
      {adding ? 'Adding...' : 'Add to Cart'}
    </button>
  );
}
```

### Pattern 2: Lifting Client Boundary

When multiple sibling components need client features, lift the boundary up:

```tsx
// ‚ùå Multiple client boundaries
<div>
  <ClientA />  {/* "use client" */}
  <ClientB />  {/* "use client" */}
  <ClientC />  {/* "use client" */}
</div>

// ‚úÖ Single client boundary
<ClientContainer>  {/* "use client" - contains A, B, C */}
  ...
</ClientContainer>
```

### Pattern 3: Extracting Client Parts

When a mostly-server component needs one client feature, extract just that part:

```tsx
// ‚ùå Whole component becomes client
"use client";

export function ProductCard({ product }) {
  const [liked, setLiked] = useState(false);
  
  return (
    <div>
      <img src={product.image} />
      <h3>{product.name}</h3>
      <p>{product.description}</p>
      {/* 100 more lines of static content */}
      <button onClick={() => setLiked(!liked)}>
        {liked ? '‚ù§Ô∏è' : 'ü§ç'}
      </button>
    </div>
  );
}

// ‚úÖ Extract only the interactive part
// ProductCard.tsx (Server)
import { LikeButton } from './LikeButton';

export function ProductCard({ product }) {
  return (
    <div>
      <img src={product.image} />
      <h3>{product.name}</h3>
      <p>{product.description}</p>
      {/* 100 more lines - stays on server */}
      <LikeButton productId={product.id} />
    </div>
  );
}

// LikeButton.tsx (Client)
"use client";

export function LikeButton({ productId }) {
  const [liked, setLiked] = useState(false);
  return (
    <button onClick={() => setLiked(!liked)}>
      {liked ? '‚ù§Ô∏è' : 'ü§ç'}
    </button>
  );
}
```

## Examples

### Basic Example: Toggle Content

```tsx
// app/page.tsx (Server)
import { Collapsible } from '@/components/Collapsible';

export default async function Page() {
  const content = await getContent();
  
  return (
    <Collapsible title="Details">
      <p>{content.details}</p>
    </Collapsible>
  );
}

// components/Collapsible.tsx (Client)
"use client";

import { useState } from 'react';

export function Collapsible({ title, children }) {
  const [isOpen, setIsOpen] = useState(false);
  
  return (
    <div>
      <button onClick={() => setIsOpen(!isOpen)}>
        {title} {isOpen ? '‚ñº' : '‚ñ∂'}
      </button>
      {isOpen && <div>{children}</div>}
    </div>
  );
}
```

### Normal Example: Dashboard with Multiple Slots

```tsx
// app/dashboard/page.tsx (Server)
import { DashboardLayout } from '@/components/DashboardLayout';
import { StatsCards } from '@/components/StatsCards';
import { RecentOrders } from '@/components/RecentOrders';
import { QuickActions } from '@/components/QuickActions';

export default async function Dashboard() {
  const stats = await getStats();
  const orders = await getRecentOrders();
  
  return (
    <DashboardLayout
      stats={<StatsCards stats={stats} />}
      orders={<RecentOrders orders={orders} />}
      actions={<QuickActions />}
    />
  );
}

// components/DashboardLayout.tsx (Client)
"use client";

import { useState } from 'react';

export function DashboardLayout({ stats, orders, actions }) {
  const [activeTab, setActiveTab] = useState('overview');
  
  return (
    <div className="dashboard">
      <nav>
        <button 
          onClick={() => setActiveTab('overview')}
          className={activeTab === 'overview' ? 'active' : ''}
        >
          Overview
        </button>
        <button 
          onClick={() => setActiveTab('orders')}
          className={activeTab === 'orders' ? 'active' : ''}
        >
          Orders
        </button>
      </nav>
      
      <div className="content">
        {activeTab === 'overview' && (
          <>
            <section>{stats}</section>
            <section>{actions}</section>
          </>
        )}
        {activeTab === 'orders' && (
          <section>{orders}</section>
        )}
      </div>
    </div>
  );
}

// components/StatsCards.tsx (Server - no "use client")
export function StatsCards({ stats }) {
  return (
    <div className="stats-grid">
      <div className="stat">
        <h3>Revenue</h3>
        <p>${stats.revenue.toLocaleString()}</p>
      </div>
      <div className="stat">
        <h3>Orders</h3>
        <p>{stats.orders}</p>
      </div>
      <div className="stat">
        <h3>Customers</h3>
        <p>{stats.customers}</p>
      </div>
    </div>
  );
}
```

### Complex Example: Modal with Server Content

```tsx
// app/products/page.tsx (Server)
import { ProductGrid } from '@/components/ProductGrid';
import { ProductModal } from '@/components/ProductModal';

export default async function ProductsPage({ searchParams }) {
  const products = await getProducts();
  const { productId } = await searchParams;
  
  // If productId in URL, fetch that product for modal
  const selectedProduct = productId 
    ? await getProduct(productId)
    : null;
  
  return (
    <>
      <ProductGrid products={products} />
      {selectedProduct && (
        <ProductModal>
          {/* Server Component rendered inside Client modal */}
          <ProductDetails product={selectedProduct} />
        </ProductModal>
      )}
    </>
  );
}

// components/ProductModal.tsx (Client)
"use client";

import { useRouter } from 'next/navigation';

export function ProductModal({ children }) {
  const router = useRouter();
  
  const handleClose = () => {
    router.push('/products');
  };
  
  return (
    <div className="modal-overlay" onClick={handleClose}>
      <div className="modal" onClick={e => e.stopPropagation()}>
        <button className="close" onClick={handleClose}>√ó</button>
        {children}
      </div>
    </div>
  );
}

// components/ProductDetails.tsx (Server)
export async function ProductDetails({ product }) {
  // Can fetch additional data if needed
  const reviews = await getReviews(product.id);
  
  return (
    <div className="product-details">
      <img src={product.image} alt={product.name} />
      <h2>{product.name}</h2>
      <p className="price">${product.price}</p>
      <p>{product.description}</p>
      
      <div className="reviews">
        <h3>Reviews ({reviews.length})</h3>
        {reviews.map(review => (
          <div key={review.id} className="review">
            <p>{review.text}</p>
            <span>{review.author}</span>
          </div>
        ))}
      </div>
    </div>
  );
}
```

### Edge Case Example: Third-Party Component Wrappers

```tsx
// components/MapWrapper.tsx
"use client";

// Third-party map library that requires client-side
import { Map, Marker } from 'react-map-gl';

export function MapWrapper({ center, markers, children }) {
  return (
    <Map
      initialViewState={{
        longitude: center.lng,
        latitude: center.lat,
        zoom: 10
      }}
    >
      {markers.map(marker => (
        <Marker 
          key={marker.id}
          longitude={marker.lng}
          latitude={marker.lat}
        />
      ))}
      {children}  {/* Allow passing server content as overlay */}
    </Map>
  );
}

// app/locations/page.tsx (Server)
import { MapWrapper } from '@/components/MapWrapper';

export default async function LocationsPage() {
  const locations = await getLocations();
  
  const center = { lat: 40.7128, lng: -74.006 };
  const markers = locations.map(loc => ({
    id: loc.id,
    lat: loc.latitude,
    lng: loc.longitude,
  }));
  
  return (
    <MapWrapper center={center} markers={markers}>
      {/* Server-rendered info panel overlaid on map */}
      <div className="info-panel">
        <h2>Our Locations</h2>
        <ul>
          {locations.map(loc => (
            <li key={loc.id}>{loc.name}</li>
          ))}
        </ul>
      </div>
    </MapWrapper>
  );
}
```

## Anti-Patterns to Avoid

### ‚ùå Importing Server Components in Client Components

```tsx
// components/ClientWrapper.tsx
"use client";

// ‚ùå This doesn't work!
import { ServerComponent } from './ServerComponent';

export function ClientWrapper() {
  return <ServerComponent />;
}
```

### ‚ùå Passing Non-Serializable Props

```tsx
// ‚ùå Functions can't be serialized
<ClientComponent onClick={() => console.log('clicked')} />

// ‚ùå Date objects can't be serialized
<ClientComponent date={new Date()} />
```

### ‚ùå Making Everything Client Components

```tsx
// ‚ùå Don't do this
"use client"; // At the top of every file

// This defeats the purpose of Server Components
```

## Key Takeaways

- Use the children pattern to pass Server Components to Client Components
- Slot props (`header`, `sidebar`, etc.) work the same as children
- Context providers must be Client Components, but can wrap Server Components
- Extract only the interactive parts into Client Components
- Organize to minimize the client boundary
- Third-party libraries often need client wrappers

## Questions & Answers

### Q: Can I use context in Server Components?
**A:** No. React Context is a client-side feature. Use props to pass data through Server Components, then context within Client Component trees.

### Q: What if a third-party component needs client features?
**A:** Create a client wrapper that imports the library and exports your component. Mark it with `"use client"`.

### Q: How do I share state between Server and Client Components?
**A:** Server Components can't have state. Pass initial data to Client Components as props, and use URL state (searchParams) for state that should survive refresh.

### Q: Can I conditionally render Server Components in Client Components?
**A:** You can conditionally render children that happen to be Server Components, but you can't import and conditionally render Server Components directly.

### Q: Should I create wrapper components for every third-party library?
**A:** Only for libraries that need client features. Pure utility libraries and those that don't use hooks/browser APIs work in Server Components.

## Resources

- [Next.js: Composition Patterns](https://nextjs.org/docs/app/building-your-application/rendering/composition-patterns)
- [React: Patterns for Server Components](https://react.dev/reference/rsc/server-components#using-server-components)
- [Vercel: Rendering Fundamentals](https://nextjs.org/docs/app/building-your-application/rendering)

---

**Next:** [6.3 Common Mistakes & Gotchas](./06.3-common-mistakes.md) - Learn what to avoid when working with Server and Client Components.
