# Chapter 4.1: File Conventions

## Overview

The App Router uses special file names to create UI for different purposes. Each file has a specific role and renders in a predictable order. Understanding these conventions is essential for building Next.js applications.

## The Component Hierarchy

When a route is rendered, files are nested in a specific order:

```tsx
<Layout>
  <Template>
    <ErrorBoundary fallback={<Error />}>
      <Suspense fallback={<Loading />}>
        <ErrorBoundary fallback={<NotFound />}>
          <Page />
        </ErrorBoundary>
      </Suspense>
    </ErrorBoundary>
  </Template>
</Layout>
```

This means:
- Layouts wrap everything
- Templates are inside layouts
- Error boundaries catch errors
- Loading states show during suspense
- The page renders at the center

## page.tsx

The `page.tsx` file makes a route publicly accessible. Without it, a folder is just for organization.

### Basic Page

```tsx
// app/page.tsx
export default function Home() {
  return (
    <main>
      <h1>Welcome to my site</h1>
    </main>
  );
}
```

### Async Page (Server Component)

```tsx
// app/products/page.tsx
async function getProducts() {
  const res = await fetch('https://api.example.com/products');
  return res.json();
}

export default async function ProductsPage() {
  const products = await getProducts();
  
  return (
    <main>
      <h1>Products</h1>
      <ul>
        {products.map(product => (
          <li key={product.id}>{product.name}</li>
        ))}
      </ul>
    </main>
  );
}
```

### Page with Params

Dynamic route segments are passed as props:

```tsx
// app/blog/[slug]/page.tsx
export default async function BlogPost({ params }) {
  const { slug } = await params;
  
  return <article>Post: {slug}</article>;
}
```

### Page with Search Params

URL query parameters are also available:

```tsx
// app/search/page.tsx
// URL: /search?q=nextjs&page=2

export default async function SearchPage({ searchParams }) {
  const { q, page } = await searchParams;
  
  return (
    <div>
      <p>Searching for: {q}</p>
      <p>Page: {page}</p>
    </div>
  );
}
```

## layout.tsx

Layouts wrap pages and other layouts. They persist across navigations—the component doesn't unmount when moving between pages that share the layout.

### Root Layout (Required)

Every app needs a root layout at `app/layout.tsx`:

```tsx
// app/layout.tsx
export default function RootLayout({ children }) {
  return (
    <html lang="en">
      <body>{children}</body>
    </html>
  );
}
```

The root layout must include `<html>` and `<body>` tags.

### Nested Layout

```tsx
// app/dashboard/layout.tsx
export default function DashboardLayout({ children }) {
  return (
    <div className="dashboard">
      <aside className="sidebar">
        <nav>
          <a href="/dashboard">Overview</a>
          <a href="/dashboard/settings">Settings</a>
          <a href="/dashboard/billing">Billing</a>
        </nav>
      </aside>
      <main className="content">
        {children}
      </main>
    </div>
  );
}
```

### Layout with Data

Layouts can be async and fetch data:

```tsx
// app/dashboard/layout.tsx
async function getUser() {
  const res = await fetch('https://api.example.com/user');
  return res.json();
}

export default async function DashboardLayout({ children }) {
  const user = await getUser();
  
  return (
    <div className="dashboard">
      <header>
        <span>Welcome, {user.name}</span>
      </header>
      <main>{children}</main>
    </div>
  );
}
```

### Layout Behavior

Key characteristics:
- **Persist across navigation**: Layout state is preserved
- **Don't re-render**: When navigating between sibling pages
- **Can't access pathname**: Layouts don't know the current route
- **Can't access searchParams**: Unlike pages

```tsx
// ❌ This won't work in a layout
export default function Layout({ children, searchParams }) {
  // searchParams is not available in layouts!
}
```

## loading.tsx

Creates an instant loading state using React Suspense. Shown automatically while the page's async content loads.

### Basic Loading

```tsx
// app/dashboard/loading.tsx
export default function Loading() {
  return <p>Loading...</p>;
}
```

### Skeleton Loading

```tsx
// app/dashboard/loading.tsx
export default function Loading() {
  return (
    <div className="skeleton">
      <div className="skeleton-header" />
      <div className="skeleton-content">
        <div className="skeleton-line" />
        <div className="skeleton-line" />
        <div className="skeleton-line short" />
      </div>
    </div>
  );
}
```

### Loading with Spinner

```tsx
// app/products/loading.tsx
export default function Loading() {
  return (
    <div className="loading-container">
      <div className="spinner" />
      <p>Loading products...</p>
    </div>
  );
}
```

### How Loading Works

`loading.tsx` automatically wraps `page.tsx` in a Suspense boundary:

```tsx
// What Next.js does internally
<Layout>
  <Suspense fallback={<Loading />}>
    <Page />
  </Suspense>
</Layout>
```

The loading state shows immediately while the page (and its data) loads.

## error.tsx

Creates an error boundary for a route segment. Catches errors in the page and its children.

### Basic Error

```tsx
// app/dashboard/error.tsx
'use client'; // Error components must be Client Components

export default function Error({ error, reset }) {
  return (
    <div className="error">
      <h2>Something went wrong!</h2>
      <p>{error.message}</p>
      <button onClick={() => reset()}>Try again</button>
    </div>
  );
}
```

### Error with Logging

```tsx
// app/dashboard/error.tsx
'use client';

import { useEffect } from 'react';

export default function Error({ error, reset }) {
  useEffect(() => {
    // Log to error reporting service
    console.error('Dashboard error:', error);
  }, [error]);
  
  return (
    <div className="error">
      <h2>Dashboard Error</h2>
      <p>We couldn't load the dashboard.</p>
      <button onClick={() => reset()}>Retry</button>
    </div>
  );
}
```

### Error Behavior

Important characteristics:
- **Must be Client Components**: Use `'use client'`
- **Catches errors in subtree**: Not in the same segment's layout
- **Receives `error` and `reset`**: `reset()` attempts to re-render

To catch errors in a layout, place `error.tsx` in the parent segment.

### Global Error Handler

For root layout errors, use `global-error.tsx`:

```tsx
// app/global-error.tsx
'use client';

export default function GlobalError({ error, reset }) {
  return (
    <html>
      <body>
        <h2>Something went wrong!</h2>
        <button onClick={() => reset()}>Try again</button>
      </body>
    </html>
  );
}
```

`global-error.tsx` must define its own `<html>` and `<body>` tags.

## not-found.tsx

Handles 404 errors for a route segment. Triggered by the `notFound()` function or when a route doesn't exist.

### Basic Not Found

```tsx
// app/not-found.tsx
export default function NotFound() {
  return (
    <div className="not-found">
      <h2>Page Not Found</h2>
      <p>The page you're looking for doesn't exist.</p>
      <a href="/">Go home</a>
    </div>
  );
}
```

### Triggering Not Found

Use the `notFound()` function to trigger the not-found UI:

```tsx
// app/blog/[slug]/page.tsx
import { notFound } from 'next/navigation';

async function getPost(slug) {
  const res = await fetch(`https://api.example.com/posts/${slug}`);
  if (!res.ok) return null;
  return res.json();
}

export default async function BlogPost({ params }) {
  const { slug } = await params;
  const post = await getPost(slug);
  
  if (!post) {
    notFound(); // Renders not-found.tsx
  }
  
  return <article>{post.title}</article>;
}
```

### Segment-Specific Not Found

```tsx
// app/blog/not-found.tsx
import Link from 'next/link';

export default function BlogNotFound() {
  return (
    <div className="not-found">
      <h2>Blog Post Not Found</h2>
      <p>We couldn't find that blog post.</p>
      <Link href="/blog">View all posts</Link>
    </div>
  );
}
```

## template.tsx

Like layout, but creates a new instance on every navigation. The component remounts, state resets.

### When to Use Template

Use `template.tsx` when you need:
- Fresh state on navigation
- useEffect to run on every navigation
- Different behavior than persistent layouts

```tsx
// app/dashboard/template.tsx
'use client';

import { useEffect } from 'react';

export default function DashboardTemplate({ children }) {
  useEffect(() => {
    // Runs on every navigation to a dashboard page
    console.log('Dashboard page viewed');
    trackPageView();
  }, []);
  
  return <div className="dashboard-template">{children}</div>;
}
```

### Template vs Layout

```tsx
// layout.tsx - Component persists
export default function Layout({ children }) {
  // State preserved across navigations
  const [count, setCount] = useState(0);
  return <div>{children}</div>;
}

// template.tsx - Component remounts
export default function Template({ children }) {
  // State resets on every navigation
  const [count, setCount] = useState(0);
  return <div>{children}</div>;
}
```

## Examples

### Basic Example: Simple Route

```
app/
├── layout.tsx
├── page.tsx
└── about/
    └── page.tsx
```

```tsx
// app/layout.tsx
export default function RootLayout({ children }) {
  return (
    <html lang="en">
      <body>
        <nav>
          <a href="/">Home</a>
          <a href="/about">About</a>
        </nav>
        {children}
      </body>
    </html>
  );
}

// app/page.tsx
export default function Home() {
  return <h1>Home Page</h1>;
}

// app/about/page.tsx
export default function About() {
  return <h1>About Page</h1>;
}
```

### Normal Example: Dashboard with Loading

```
app/
└── dashboard/
    ├── layout.tsx
    ├── loading.tsx
    ├── error.tsx
    ├── page.tsx
    └── settings/
        └── page.tsx
```

```tsx
// app/dashboard/layout.tsx
export default function DashboardLayout({ children }) {
  return (
    <div className="dashboard-layout">
      <aside>
        <nav>
          <a href="/dashboard">Overview</a>
          <a href="/dashboard/settings">Settings</a>
        </nav>
      </aside>
      <main>{children}</main>
    </div>
  );
}

// app/dashboard/loading.tsx
export default function DashboardLoading() {
  return (
    <div className="loading">
      <div className="spinner" />
      <p>Loading dashboard...</p>
    </div>
  );
}

// app/dashboard/error.tsx
'use client';

export default function DashboardError({ error, reset }) {
  return (
    <div className="error">
      <h2>Dashboard Error</h2>
      <button onClick={reset}>Retry</button>
    </div>
  );
}

// app/dashboard/page.tsx
async function getDashboardData() {
  const res = await fetch('https://api.example.com/dashboard');
  return res.json();
}

export default async function Dashboard() {
  const data = await getDashboardData();
  
  return (
    <div>
      <h1>Dashboard</h1>
      <p>Welcome back! You have {data.notifications} notifications.</p>
    </div>
  );
}
```

### Complex Example: Full Blog Structure

```
app/
├── layout.tsx
├── page.tsx
├── not-found.tsx
└── blog/
    ├── layout.tsx
    ├── loading.tsx
    ├── error.tsx
    ├── page.tsx
    ├── not-found.tsx
    └── [slug]/
        ├── loading.tsx
        ├── page.tsx
        └── not-found.tsx
```

```tsx
// app/blog/layout.tsx
export default function BlogLayout({ children }) {
  return (
    <div className="blog-layout">
      <header className="blog-header">
        <h1>My Blog</h1>
        <p>Thoughts on development</p>
      </header>
      {children}
      <footer className="blog-footer">
        <p>Subscribe to my newsletter</p>
      </footer>
    </div>
  );
}

// app/blog/page.tsx
async function getPosts() {
  const res = await fetch('https://api.example.com/posts');
  return res.json();
}

export default async function BlogIndex() {
  const posts = await getPosts();
  
  return (
    <div className="posts">
      {posts.map(post => (
        <article key={post.id}>
          <h2><a href={`/blog/${post.slug}`}>{post.title}</a></h2>
          <p>{post.excerpt}</p>
        </article>
      ))}
    </div>
  );
}

// app/blog/[slug]/page.tsx
import { notFound } from 'next/navigation';

async function getPost(slug) {
  const res = await fetch(`https://api.example.com/posts/${slug}`);
  if (!res.ok) return null;
  return res.json();
}

export default async function BlogPost({ params }) {
  const { slug } = await params;
  const post = await getPost(slug);
  
  if (!post) {
    notFound();
  }
  
  return (
    <article className="post">
      <h1>{post.title}</h1>
      <time>{new Date(post.date).toLocaleDateString()}</time>
      <div dangerouslySetInnerHTML={{ __html: post.content }} />
    </article>
  );
}

// app/blog/[slug]/not-found.tsx
import Link from 'next/link';

export default function PostNotFound() {
  return (
    <div className="not-found">
      <h2>Post Not Found</h2>
      <p>This blog post doesn't exist or has been removed.</p>
      <Link href="/blog">← Back to all posts</Link>
    </div>
  );
}
```

### Edge Case Example: Handling Various States

```tsx
// app/products/[id]/page.tsx
import { notFound } from 'next/navigation';

async function getProduct(id) {
  try {
    const res = await fetch(`https://api.example.com/products/${id}`, {
      next: { revalidate: 3600 } // Cache for 1 hour
    });
    
    if (res.status === 404) {
      return { error: 'not_found' };
    }
    
    if (!res.ok) {
      throw new Error(`HTTP ${res.status}`);
    }
    
    return { data: await res.json() };
  } catch (error) {
    return { error: 'fetch_failed', message: error.message };
  }
}

export default async function ProductPage({ params }) {
  const { id } = await params;
  
  // Validate ID format
  if (!/^\d+$/.test(id)) {
    notFound();
  }
  
  const result = await getProduct(id);
  
  // Handle not found
  if (result.error === 'not_found') {
    notFound();
  }
  
  // Handle other errors (will be caught by error.js)
  if (result.error) {
    throw new Error(result.message || 'Failed to load product');
  }
  
  const product = result.data;
  
  return (
    <div className="product">
      <h1>{product.name}</h1>
      <p>${product.price}</p>
      {product.inStock ? (
        <button>Add to Cart</button>
      ) : (
        <p className="out-of-stock">Out of Stock</p>
      )}
    </div>
  );
}
```

## Key Takeaways

- `page.tsx` makes a route accessible
- `layout.tsx` wraps pages and persists across navigation
- `loading.tsx` shows instant loading states
- `error.tsx` catches and handles errors (must be a Client Component)
- `not-found.tsx` handles 404 cases
- `template.tsx` is like layout but remounts on navigation
- The root layout is required and must include `<html>` and `<body>`
- Files render in a specific hierarchy: layout → template → error → loading → page

## Questions & Answers

### Q: Why is error.tsx a Client Component?
**A:** Error boundaries in React must be class components or use client-side hooks like useState. The `reset()` function needs to re-render the client-side tree.

### Q: Can I have loading.tsx without page.tsx?
**A:** Yes, but it won't do anything useful. loading.tsx wraps page.tsx, so without a page, there's nothing to show a loading state for.

### Q: Why doesn't my not-found.tsx show?
**A:** Make sure you're calling `notFound()` from `next/navigation` in your page. Just returning null or an empty component won't trigger it.

### Q: Can layouts access the current URL?
**A:** Not directly. Layouts don't receive pathname or searchParams. Use client-side hooks in a Client Component if you need URL information.

### Q: Does loading.tsx work for client-side navigation?
**A:** Yes. The loading state shows during both initial server render and client-side navigation if the destination page has async data.

## Resources

- [Next.js: Special Files](https://nextjs.org/docs/app/building-your-application/routing#file-conventions)
- [Next.js: Pages and Layouts](https://nextjs.org/docs/app/building-your-application/routing/pages-and-layouts)
- [Next.js: Loading UI and Streaming](https://nextjs.org/docs/app/building-your-application/routing/loading-ui-and-streaming)
- [Next.js: Error Handling](https://nextjs.org/docs/app/building-your-application/routing/error-handling)

