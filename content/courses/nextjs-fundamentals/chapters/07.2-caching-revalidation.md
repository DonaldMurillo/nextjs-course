# Chapter 7.2: Caching & Revalidation

## Overview

Caching is one of Next.js's most powerful features—and most confusing. Understanding when data is cached, how long it's cached, and how to invalidate it is essential for building performant applications.

## Cache Types in Next.js

Next.js has multiple cache layers:

```
Browser ──→ Router Cache ──→ Full Route Cache ──→ Data Cache ──→ Origin
           (in-memory)      (on server)          (on server)
```

| Cache | Location | Duration | Purpose |
|-------|----------|----------|---------|
| **Data Cache** | Server | Persistent | Cache fetch responses |
| **Full Route Cache** | Server | Persistent | Cache rendered HTML |
| **Router Cache** | Browser | Session | Cache visited pages |

## Data Cache

The Data Cache stores the results of `fetch` requests on the server.

### Next.js 15 Defaults

In Next.js 15, fetch requests are **not cached by default**:

```tsx
// Not cached (default in Next.js 15)
const data = await fetch('https://api.example.com/data');
```

### Opting Into Caching

Use cache options to enable caching:

```tsx
// Cache indefinitely (until redeployed)
const data = await fetch('https://api.example.com/data', {
  cache: 'force-cache'
});

// Cache for a specific time
const data = await fetch('https://api.example.com/data', {
  next: { revalidate: 3600 }  // 1 hour
});

// Never cache
const data = await fetch('https://api.example.com/data', {
  cache: 'no-store'
});
```

### Cache Options Reference

| Option | Behavior |
|--------|----------|
| `cache: 'force-cache'` | Cache indefinitely |
| `cache: 'no-store'` | Never cache |
| `next: { revalidate: N }` | Cache for N seconds |
| `next: { revalidate: 0 }` | Same as no-store |
| `next: { tags: ['tag'] }` | Tag for on-demand revalidation |

## Time-Based Revalidation

Set a time after which cached data becomes stale:

```tsx
// Revalidate every hour
const posts = await fetch('https://api.example.com/posts', {
  next: { revalidate: 3600 }
});

// Revalidate every minute
const prices = await fetch('https://api.example.com/prices', {
  next: { revalidate: 60 }
});

// Revalidate every day
const config = await fetch('https://api.example.com/config', {
  next: { revalidate: 86400 }
});
```

### How It Works

1. First request: Fetch from origin, cache result
2. Within revalidate window: Serve from cache
3. After window: Serve stale cache, fetch fresh data in background
4. Next request: Serve fresh data

This is "stale-while-revalidate" behavior.

### Route Segment Config

Set revalidation for an entire route:

```tsx
// app/products/page.tsx
export const revalidate = 3600;  // Revalidate every hour

export default async function ProductsPage() {
  // All fetches in this page default to 1 hour revalidation
  const products = await fetch('https://api.example.com/products');
  return <ProductList products={products} />;
}
```

## On-Demand Revalidation

Invalidate cache manually when data changes.

### Using revalidatePath

Revalidate all data for a specific path:

```tsx
// app/actions.ts
'use server';

import { revalidatePath } from 'next/cache';

export async function createPost(formData) {
  // Save to database
  await db.posts.create({ data: formData });
  
  // Revalidate the posts page
  revalidatePath('/posts');
}
```

### Using revalidateTag

Revalidate all fetches with a specific tag:

```tsx
// Fetch with tag
const posts = await fetch('https://api.example.com/posts', {
  next: { tags: ['posts'] }
});

// Revalidate by tag
import { revalidateTag } from 'next/cache';

export async function createPost(formData) {
  await db.posts.create({ data: formData });
  revalidateTag('posts');  // All fetches tagged 'posts' are revalidated
}
```

### Multiple Tags

```tsx
const post = await fetch(`https://api.example.com/posts/${id}`, {
  next: { tags: ['posts', `post-${id}`] }
});

// Revalidate single post
revalidateTag(`post-${id}`);

// Revalidate all posts
revalidateTag('posts');
```

### In Route Handlers

```tsx
// app/api/revalidate/route.ts
import { revalidateTag, revalidatePath } from 'next/cache';
import { NextResponse } from 'next/server';

export async function POST(request) {
  const { tag, path, secret } = await request.json();
  
  // Validate secret
  if (secret !== process.env.REVALIDATION_SECRET) {
    return NextResponse.json({ error: 'Invalid secret' }, { status: 401 });
  }
  
  if (tag) {
    revalidateTag(tag);
    return NextResponse.json({ revalidated: true, tag });
  }
  
  if (path) {
    revalidatePath(path);
    return NextResponse.json({ revalidated: true, path });
  }
  
  return NextResponse.json({ error: 'Missing tag or path' }, { status: 400 });
}
```

## Route Cache Behavior

### Static vs Dynamic Routes

```tsx
// Static: Cached at build time
// app/about/page.tsx
export default function About() {
  return <h1>About Us</h1>;
}

// Dynamic: Rendered on each request
// app/dashboard/page.tsx
export const dynamic = 'force-dynamic';

export default async function Dashboard() {
  const data = await fetchUserData();
  return <DashboardView data={data} />;
}
```

### Dynamic Functions

Using these makes a route dynamic:
- `cookies()`
- `headers()`
- `searchParams`
- `fetch` with `cache: 'no-store'`

```tsx
import { cookies } from 'next/headers';

export default async function Page() {
  const cookieStore = await cookies();  // Makes route dynamic
  const theme = cookieStore.get('theme');
  return <ThemedPage theme={theme?.value} />;
}
```

## Examples

### Basic Example: Static with Revalidation

```tsx
// app/blog/page.tsx
async function getPosts() {
  const res = await fetch('https://api.example.com/posts', {
    next: { revalidate: 3600 }  // Revalidate hourly
  });
  return res.json();
}

export default async function BlogPage() {
  const posts = await getPosts();
  
  return (
    <div>
      <h1>Blog</h1>
      {posts.map(post => (
        <article key={post.id}>
          <h2>{post.title}</h2>
          <p>{post.excerpt}</p>
        </article>
      ))}
    </div>
  );
}
```

### Normal Example: Mixed Caching Strategies

```tsx
// app/products/[id]/page.tsx
async function getProduct(id) {
  // Product details change rarely - cache for 1 day
  const res = await fetch(`https://api.example.com/products/${id}`, {
    next: { 
      revalidate: 86400,
      tags: [`product-${id}`]
    }
  });
  return res.json();
}

async function getPrice(id) {
  // Prices change often - cache for 1 minute
  const res = await fetch(`https://api.example.com/prices/${id}`, {
    next: { revalidate: 60 }
  });
  return res.json();
}

async function getInventory(id) {
  // Inventory is real-time - no cache
  const res = await fetch(`https://api.example.com/inventory/${id}`, {
    cache: 'no-store'
  });
  return res.json();
}

export default async function ProductPage({ params }) {
  const { id } = await params;
  
  const [product, price, inventory] = await Promise.all([
    getProduct(id),
    getPrice(id),
    getInventory(id),
  ]);
  
  return (
    <div>
      <h1>{product.name}</h1>
      <p>{product.description}</p>
      <p className="price">${price.amount}</p>
      <p className="stock">
        {inventory.inStock ? `${inventory.quantity} in stock` : 'Out of stock'}
      </p>
    </div>
  );
}
```

### Complex Example: On-Demand Revalidation with Webhooks

```tsx
// app/api/webhook/route.ts
import { revalidateTag, revalidatePath } from 'next/cache';
import { NextResponse } from 'next/server';
import crypto from 'crypto';

function verifySignature(payload, signature, secret) {
  const expected = crypto
    .createHmac('sha256', secret)
    .update(payload)
    .digest('hex');
  return crypto.timingSafeEqual(
    Buffer.from(signature),
    Buffer.from(expected)
  );
}

export async function POST(request) {
  const payload = await request.text();
  const signature = request.headers.get('x-webhook-signature');
  
  // Verify webhook signature
  if (!verifySignature(payload, signature, process.env.WEBHOOK_SECRET)) {
    return NextResponse.json({ error: 'Invalid signature' }, { status: 401 });
  }
  
  const event = JSON.parse(payload);
  
  // Handle different event types
  switch (event.type) {
    case 'product.created':
    case 'product.updated':
    case 'product.deleted':
      revalidateTag('products');
      revalidateTag(`product-${event.data.id}`);
      revalidatePath('/products');
      revalidatePath(`/products/${event.data.id}`);
      break;
      
    case 'post.published':
      revalidateTag('posts');
      revalidatePath('/blog');
      break;
      
    case 'settings.changed':
      // Revalidate entire site
      revalidatePath('/', 'layout');
      break;
  }
  
  return NextResponse.json({ received: true });
}

// lib/data.ts
export async function getProducts() {
  const res = await fetch('https://api.example.com/products', {
    next: { tags: ['products'] }
  });
  return res.json();
}

export async function getProduct(id) {
  const res = await fetch(`https://api.example.com/products/${id}`, {
    next: { tags: ['products', `product-${id}`] }
  });
  return res.json();
}
```

### Edge Case Example: Handling Cache During Development

```tsx
// lib/data.ts
const isDev = process.env.NODE_ENV === 'development';

export async function getData() {
  const res = await fetch('https://api.example.com/data', {
    // In dev, disable cache for easier debugging
    // In prod, cache for 1 hour
    cache: isDev ? 'no-store' : undefined,
    next: isDev ? undefined : { revalidate: 3600 }
  });
  
  return res.json();
}

// Or use route segment config
// app/debug/page.tsx
export const dynamic = process.env.NODE_ENV === 'development' 
  ? 'force-dynamic' 
  : 'auto';

export const revalidate = process.env.NODE_ENV === 'development'
  ? 0
  : 3600;
```

## Caching Non-Fetch Data

For database queries and other non-fetch data, use `unstable_cache`:

```tsx
import { unstable_cache } from 'next/cache';
import { prisma } from '@/lib/prisma';

const getCachedUser = unstable_cache(
  async (userId) => {
    return prisma.user.findUnique({
      where: { id: userId },
    });
  },
  ['user'],  // Cache key parts
  {
    tags: ['users'],
    revalidate: 3600,
  }
);

export default async function UserPage({ params }) {
  const { id } = await params;
  const user = await getCachedUser(id);
  
  return <UserProfile user={user} />;
}
```

## Route Segment Config Options

```tsx
// app/page.tsx

// Force dynamic rendering
export const dynamic = 'force-dynamic';

// Force static rendering (error if dynamic features used)
export const dynamic = 'force-static';

// Default: auto-detect
export const dynamic = 'auto';

// Revalidation time in seconds
export const revalidate = 3600;

// Disable revalidation (static forever)
export const revalidate = false;

// Always revalidate (dynamic)
export const revalidate = 0;

// Runtime: 'nodejs' (default) or 'edge'
export const runtime = 'edge';
```

## Debugging Cache

### Check Cache Status

In development, check the terminal output:

```
GET /products 200 in 50ms (cache: HIT)
GET /products 200 in 500ms (cache: MISS)
```

### Headers in Production

Check response headers:
- `x-nextjs-cache: HIT` - Served from cache
- `x-nextjs-cache: MISS` - Freshly rendered

### Force Revalidation During Development

```bash
# Delete .next folder to clear all caches
rm -rf .next
npm run dev
```

## Key Takeaways

- Next.js 15 doesn't cache fetch by default—opt in explicitly
- Use `next: { revalidate: N }` for time-based caching
- Use `next: { tags: [] }` with `revalidateTag()` for on-demand invalidation
- `revalidatePath()` invalidates all data for a specific route
- Dynamic functions (`cookies()`, `headers()`) make routes dynamic
- Use `unstable_cache` for non-fetch data sources
- Different data can have different cache strategies in the same page

## Questions & Answers

### Q: Why is my data not updating?
**A:** Check: 1) Cache settings on fetch, 2) Route segment config, 3) Whether you're in dev or prod (caching differs), 4) Clear `.next` folder.

### Q: What's the difference between revalidatePath and revalidateTag?
**A:** `revalidatePath` invalidates a specific URL path. `revalidateTag` invalidates all fetches with that tag, regardless of which pages use them.

### Q: Does caching work in development?
**A:** Partially. Some cache behaviors only work in production. Test caching with `npm run build && npm start`.

### Q: How do I cache database queries?
**A:** Use `unstable_cache` from `next/cache` or implement your own caching layer (Redis, etc.).

### Q: Can I have different revalidation times for different fetches in the same page?
**A:** Yes! Each fetch can have its own `revalidate` setting.

## Resources

- [Next.js: Caching](https://nextjs.org/docs/app/building-your-application/caching)
- [Next.js: revalidatePath](https://nextjs.org/docs/app/api-reference/functions/revalidatePath)
- [Next.js: revalidateTag](https://nextjs.org/docs/app/api-reference/functions/revalidateTag)
- [Next.js: Route Segment Config](https://nextjs.org/docs/app/api-reference/file-conventions/route-segment-config)

