# Chapter 3.4: Hooks

## What Are Hooks?

Hooks are functions that let you "hook into" React features from function components. They let you use state, side effects, refs, and other React features without writing class components.

Hooks follow two rules:
1. **Only call hooks at the top level** — not inside loops, conditions, or nested functions
2. **Only call hooks from React functions** — components or custom hooks

```tsx
// ✅ Correct: Top level of component
function Component() {
  const [count, setCount] = useState(0);
  
  useEffect(() => {
    // ...
  }, []);
  
  return <div>{count}</div>;
}

// ❌ Wrong: Inside condition
function Component() {
  if (someCondition) {
    const [count, setCount] = useState(0); // Error!
  }
}
```

## useState (Review)

Covered in Chapter 3.3. Quick reference:

```tsx
import { useState } from 'react';

const [value, setValue] = useState(initialValue);

// Update with new value
setValue(newValue);

// Update based on previous value
setValue(prev => prev + 1);
```

## useEffect

`useEffect` lets you perform side effects: data fetching, subscriptions, DOM manipulation, timers, and anything that affects things outside the component.

```tsx
import { useEffect } from 'react';

useEffect(() => {
  // Effect code runs after render
  
  return () => {
    // Cleanup code runs before next effect or unmount
  };
}, [dependencies]);
```

### Effect Timing

- Effect runs **after** the component renders
- Cleanup runs **before** the next effect runs, and on unmount

### Dependency Array

The dependency array controls when the effect runs:

```tsx
// Runs after every render
useEffect(() => {
  console.log('Runs every time');
});

// Runs once on mount
useEffect(() => {
  console.log('Runs once');
}, []);

// Runs when count changes
useEffect(() => {
  console.log('Count changed:', count);
}, [count]);

// Runs when count OR name changes
useEffect(() => {
  console.log('Something changed');
}, [count, name]);
```

### Common Use Cases

#### Data Fetching

```tsx
function UserProfile({ userId }) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  
  useEffect(() => {
    async function fetchUser() {
      setLoading(true);
      try {
        const response = await fetch(`/api/users/${userId}`);
        const data = await response.json();
        setUser(data);
      } catch (error) {
        console.error('Failed to fetch user:', error);
      } finally {
        setLoading(false);
      }
    }
    
    fetchUser();
  }, [userId]); // Re-fetch when userId changes
  
  if (loading) return <p>Loading...</p>;
  if (!user) return <p>User not found</p>;
  return <h1>{user.name}</h1>;
}
```

> **Note:** In Next.js, you'll often fetch data in Server Components instead of useEffect.

#### Event Listeners

```tsx
function WindowSize() {
  const [size, setSize] = useState({ width: 0, height: 0 });
  
  useEffect(() => {
    function handleResize() {
      setSize({
        width: window.innerWidth,
        height: window.innerHeight
      });
    }
    
    // Set initial size
    handleResize();
    
    // Add listener
    window.addEventListener('resize', handleResize);
    
    // Cleanup: Remove listener
    return () => {
      window.removeEventListener('resize', handleResize);
    };
  }, []); // Empty array: run once on mount
  
  return <p>{size.width} x {size.height}</p>;
}
```

#### Timers

```tsx
function Timer() {
  const [seconds, setSeconds] = useState(0);
  
  useEffect(() => {
    const interval = setInterval(() => {
      setSeconds(prev => prev + 1);
    }, 1000);
    
    // Cleanup: Clear interval on unmount
    return () => clearInterval(interval);
  }, []);
  
  return <p>Seconds: {seconds}</p>;
}
```

#### Document Title

```tsx
function Page({ title }) {
  useEffect(() => {
    document.title = title;
  }, [title]);
  
  return <h1>{title}</h1>;
}
```

### Cleanup Function

The cleanup function prevents memory leaks and stale operations:

```tsx
useEffect(() => {
  // This might complete after component unmounts
  const controller = new AbortController();
  
  fetch('/api/data', { signal: controller.signal })
    .then(res => res.json())
    .then(data => setData(data));
  
  // Cleanup: Abort fetch if component unmounts
  return () => controller.abort();
}, []);
```

## useRef

`useRef` creates a mutable reference that persists across renders without causing re-renders when changed.

```tsx
import { useRef } from 'react';

const ref = useRef(initialValue);

// Access/modify with .current
ref.current = newValue;
```

### DOM References

The most common use—access DOM elements directly:

```tsx
function TextInput() {
  const inputRef = useRef(null);
  
  const focusInput = () => {
    inputRef.current.focus();
  };
  
  return (
    <>
      <input ref={inputRef} />
      <button onClick={focusInput}>Focus Input</button>
    </>
  );
}
```

### Storing Previous Values

```tsx
function Counter() {
  const [count, setCount] = useState(0);
  const prevCountRef = useRef();
  
  useEffect(() => {
    prevCountRef.current = count;
  });
  
  const prevCount = prevCountRef.current;
  
  return (
    <p>
      Current: {count}, Previous: {prevCount}
    </p>
  );
}
```

### Storing Mutable Values

Values that need to persist but shouldn't trigger re-renders:

```tsx
function Stopwatch() {
  const [time, setTime] = useState(0);
  const intervalRef = useRef(null);
  
  const start = () => {
    if (intervalRef.current) return; // Already running
    intervalRef.current = setInterval(() => {
      setTime(prev => prev + 1);
    }, 1000);
  };
  
  const stop = () => {
    clearInterval(intervalRef.current);
    intervalRef.current = null;
  };
  
  const reset = () => {
    stop();
    setTime(0);
  };
  
  return (
    <div>
      <p>{time} seconds</p>
      <button onClick={start}>Start</button>
      <button onClick={stop}>Stop</button>
      <button onClick={reset}>Reset</button>
    </div>
  );
}
```

## useMemo

`useMemo` memoizes expensive calculations. It only recomputes when dependencies change.

```tsx
import { useMemo } from 'react';

const memoizedValue = useMemo(() => {
  return expensiveCalculation(a, b);
}, [a, b]);
```

### When to Use

Use useMemo when:
- A calculation is genuinely expensive (complex filtering, sorting large arrays)
- You need referential equality (passing objects to memoized children)

```tsx
function ProductList({ products, filterText }) {
  // Only re-filter when products or filterText changes
  const filteredProducts = useMemo(() => {
    console.log('Filtering products...');
    return products.filter(product =>
      product.name.toLowerCase().includes(filterText.toLowerCase())
    );
  }, [products, filterText]);
  
  return (
    <ul>
      {filteredProducts.map(product => (
        <li key={product.id}>{product.name}</li>
      ))}
    </ul>
  );
}
```

### Don't Overuse

`useMemo` has overhead. Don't use it for simple operations:

```tsx
// ❌ Unnecessary - simple operation
const fullName = useMemo(() => `${firstName} ${lastName}`, [firstName, lastName]);

// ✅ Just calculate it
const fullName = `${firstName} ${lastName}`;
```

## useCallback

`useCallback` memoizes functions. It returns the same function reference unless dependencies change.

```tsx
import { useCallback } from 'react';

const memoizedFn = useCallback(() => {
  doSomething(a, b);
}, [a, b]);
```

### When to Use

Use useCallback when passing functions to memoized children or when functions are dependencies of other hooks:

```tsx
function Parent() {
  const [count, setCount] = useState(0);
  
  // Without useCallback, this creates a new function every render
  // causing Child to re-render even if it's memoized
  const handleClick = useCallback(() => {
    console.log('Clicked!');
  }, []); // No dependencies, function never changes
  
  return (
    <>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
      <MemoizedChild onClick={handleClick} />
    </>
  );
}

const MemoizedChild = React.memo(function Child({ onClick }) {
  console.log('Child rendered');
  return <button onClick={onClick}>Click me</button>;
});
```

## Custom Hooks

Custom hooks let you extract and reuse stateful logic.

### Rules for Custom Hooks

- Name starts with `use`
- Can call other hooks
- Return whatever is useful

### Example: useLocalStorage

```tsx
// hooks/useLocalStorage.ts
import { useState, useEffect } from 'react';

function useLocalStorage(key, initialValue) {
  // Get initial value from localStorage or use provided initial value
  const [value, setValue] = useState(() => {
    if (typeof window === 'undefined') return initialValue;
    
    try {
      const item = window.localStorage.getItem(key);
      return item ? JSON.parse(item) : initialValue;
    } catch (error) {
      return initialValue;
    }
  });
  
  // Update localStorage when value changes
  useEffect(() => {
    try {
      window.localStorage.setItem(key, JSON.stringify(value));
    } catch (error) {
      console.error('Error saving to localStorage:', error);
    }
  }, [key, value]);
  
  return [value, setValue];
}

// Usage
function Settings() {
  const [theme, setTheme] = useLocalStorage('theme', 'light');
  
  return (
    <select value={theme} onChange={(e) => setTheme(e.target.value)}>
      <option value="light">Light</option>
      <option value="dark">Dark</option>
    </select>
  );
}
```

### Example: useFetch

```tsx
// hooks/useFetch.ts
import { useState, useEffect } from 'react';

function useFetch(url) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  
  useEffect(() => {
    const controller = new AbortController();
    
    async function fetchData() {
      setLoading(true);
      setError(null);
      
      try {
        const response = await fetch(url, { signal: controller.signal });
        if (!response.ok) throw new Error('Request failed');
        const json = await response.json();
        setData(json);
      } catch (err) {
        if (err.name !== 'AbortError') {
          setError(err.message);
        }
      } finally {
        setLoading(false);
      }
    }
    
    fetchData();
    
    return () => controller.abort();
  }, [url]);
  
  return { data, loading, error };
}

// Usage
function UserList() {
  const { data: users, loading, error } = useFetch('/api/users');
  
  if (loading) return <p>Loading...</p>;
  if (error) return <p>Error: {error}</p>;
  return <ul>{users.map(user => <li key={user.id}>{user.name}</li>)}</ul>;
}
```

### Example: useToggle

```tsx
// hooks/useToggle.ts
import { useState, useCallback } from 'react';

function useToggle(initialValue = false) {
  const [value, setValue] = useState(initialValue);
  
  const toggle = useCallback(() => {
    setValue(prev => !prev);
  }, []);
  
  const setTrue = useCallback(() => setValue(true), []);
  const setFalse = useCallback(() => setValue(false), []);
  
  return { value, toggle, setTrue, setFalse };
}

// Usage
function Modal() {
  const { value: isOpen, toggle, setFalse: close } = useToggle();
  
  return (
    <>
      <button onClick={toggle}>Toggle Modal</button>
      {isOpen && (
        <div className="modal">
          <p>Modal content</p>
          <button onClick={close}>Close</button>
        </div>
      )}
    </>
  );
}
```

## Examples

### Basic Example

```tsx
// components/ClickTracker.tsx
import { useState, useEffect } from 'react';

function ClickTracker() {
  const [clicks, setClicks] = useState(0);
  
  useEffect(() => {
    document.title = `${clicks} clicks`;
  }, [clicks]);
  
  return (
    <button onClick={() => setClicks(clicks + 1)}>
      Clicked {clicks} times
    </button>
  );
}
```

### Normal Example

```tsx
// components/SearchResults.tsx
import { useState, useEffect, useMemo } from 'react';

function SearchResults({ items }) {
  const [query, setQuery] = useState('');
  const [sortBy, setSortBy] = useState('name');
  
  const filteredAndSorted = useMemo(() => {
    let result = items;
    
    // Filter
    if (query) {
      result = result.filter(item =>
        item.name.toLowerCase().includes(query.toLowerCase())
      );
    }
    
    // Sort
    result = [...result].sort((a, b) => {
      if (sortBy === 'name') return a.name.localeCompare(b.name);
      if (sortBy === 'price') return a.price - b.price;
      return 0;
    });
    
    return result;
  }, [items, query, sortBy]);
  
  return (
    <div>
      <input
        value={query}
        onChange={(e) => setQuery(e.target.value)}
        placeholder="Search..."
      />
      <select value={sortBy} onChange={(e) => setSortBy(e.target.value)}>
        <option value="name">Sort by Name</option>
        <option value="price">Sort by Price</option>
      </select>
      <ul>
        {filteredAndSorted.map(item => (
          <li key={item.id}>{item.name} - ${item.price}</li>
        ))}
      </ul>
    </div>
  );
}
```

### Complex Example

```tsx
// components/InfiniteScroll.tsx
import { useState, useEffect, useRef, useCallback } from 'react';

function InfiniteScroll({ fetchItems }) {
  const [items, setItems] = useState([]);
  const [page, setPage] = useState(1);
  const [loading, setLoading] = useState(false);
  const [hasMore, setHasMore] = useState(true);
  const observerRef = useRef();
  
  // Load items when page changes
  useEffect(() => {
    async function loadItems() {
      if (!hasMore) return;
      
      setLoading(true);
      try {
        const newItems = await fetchItems(page);
        setItems(prev => [...prev, ...newItems]);
        setHasMore(newItems.length > 0);
      } catch (error) {
        console.error('Failed to load items:', error);
      } finally {
        setLoading(false);
      }
    }
    
    loadItems();
  }, [page, fetchItems, hasMore]);
  
  // Intersection observer callback
  const lastItemRef = useCallback(node => {
    if (loading) return;
    
    if (observerRef.current) {
      observerRef.current.disconnect();
    }
    
    observerRef.current = new IntersectionObserver(entries => {
      if (entries[0].isIntersecting && hasMore) {
        setPage(prev => prev + 1);
      }
    });
    
    if (node) {
      observerRef.current.observe(node);
    }
  }, [loading, hasMore]);
  
  return (
    <div>
      {items.map((item, index) => {
        if (index === items.length - 1) {
          return (
            <div key={item.id} ref={lastItemRef}>
              {item.content}
            </div>
          );
        }
        return <div key={item.id}>{item.content}</div>;
      })}
      {loading && <p>Loading more...</p>}
      {!hasMore && <p>No more items</p>}
    </div>
  );
}
```

### Edge Case Example

```tsx
// components/SafeEffect.tsx
import { useState, useEffect, useRef } from 'react';

function SafeAsyncEffect({ userId }) {
  const [user, setUser] = useState(null);
  const [error, setError] = useState(null);
  const mountedRef = useRef(true);
  
  useEffect(() => {
    // Track mounted state
    mountedRef.current = true;
    
    async function fetchUser() {
      try {
        const response = await fetch(`/api/users/${userId}`);
        const data = await response.json();
        
        // Only update state if component is still mounted
        if (mountedRef.current) {
          setUser(data);
          setError(null);
        }
      } catch (err) {
        if (mountedRef.current) {
          setError(err.message);
          setUser(null);
        }
      }
    }
    
    fetchUser();
    
    return () => {
      // Mark as unmounted on cleanup
      mountedRef.current = false;
    };
  }, [userId]);
  
  // Handle rapid userId changes
  useEffect(() => {
    // Reset state when userId changes
    setUser(null);
    setError(null);
  }, [userId]);
  
  if (error) return <p>Error: {error}</p>;
  if (!user) return <p>Loading...</p>;
  return <div>{user.name}</div>;
}
```

## Key Takeaways

- Hooks let you use React features in function components
- Call hooks only at the top level, only in React functions
- `useEffect` handles side effects—data fetching, subscriptions, DOM updates
- `useRef` holds mutable values that don't trigger re-renders
- `useMemo` memoizes expensive calculations
- `useCallback` memoizes functions
- Custom hooks extract and share stateful logic

## Questions & Answers

### Q: Why can't I call hooks inside conditions?
**A:** React relies on hook call order to associate state with components. Conditional calls would break this order between renders.

### Q: When should I use useEffect vs just doing something during render?
**A:** Use useEffect for side effects—things that affect the outside world (API calls, subscriptions, DOM manipulation). Pure calculations can happen during render.

### Q: Why does my useEffect run twice in development?
**A:** React 18's Strict Mode intentionally mounts components twice to help find bugs. This only happens in development.

### Q: Should I use useMemo and useCallback everywhere?
**A:** No. They have overhead. Use them when you have measurable performance issues, or when referential equality matters (passing to memoized children).

### Q: How do I fetch data without useEffect in Next.js?
**A:** Use Server Components for data fetching when possible. They can `await` directly without useEffect. We'll cover this in Chapter 7.

### Q: Can I create a custom hook that doesn't use any built-in hooks?
**A:** Technically yes, but it's just a regular function then. Custom hooks typically compose built-in hooks or other custom hooks.

## Resources

- [React: useEffect](https://react.dev/reference/react/useEffect)
- [React: useRef](https://react.dev/reference/react/useRef)
- [React: useMemo](https://react.dev/reference/react/useMemo)
- [React: useCallback](https://react.dev/reference/react/useCallback)
- [React: Reusing Logic with Custom Hooks](https://react.dev/learn/reusing-logic-with-custom-hooks)
- [Dan Abramov: A Complete Guide to useEffect](https://overreacted.io/a-complete-guide-to-useeffect/)

---

**Next:** [3.5 Conditional Rendering & Lists](./03.5-conditional-rendering-lists.md) - Learn how to conditionally show content and render lists of data.
