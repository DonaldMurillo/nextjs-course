# Chapter 3.5: Conditional Rendering & Lists

## Conditional Rendering

React lets you render different content based on conditions. Since JSX is TypeScript, you can use any TypeScript conditional logic.

## Conditional Patterns

### If Statement (Before Return)

Use a regular if statement when you need to return completely different JSX:

```tsx
function Greeting({ isLoggedIn }) {
  if (isLoggedIn) {
    return <h1>Welcome back!</h1>;
  }
  return <h1>Please sign in</h1>;
}
```

### Ternary Operator

Use for inline conditional rendering:

```tsx
function Greeting({ isLoggedIn }) {
  return (
    <h1>
      {isLoggedIn ? 'Welcome back!' : 'Please sign in'}
    </h1>
  );
}
```

For entire elements:

```tsx
function Dashboard({ user }) {
  return (
    <div>
      {user ? (
        <UserProfile user={user} />
      ) : (
        <LoginForm />
      )}
    </div>
  );
}
```

### Logical AND (&&)

Use when you want to render something OR nothing:

```tsx
function Notification({ message }) {
  return (
    <div>
      {message && <p className="notification">{message}</p>}
    </div>
  );
}
```

**Warning:** Be careful with numbers. `0 && <Component />` renders `0`, not nothing:

```tsx
// ❌ Bug: Shows "0" when count is 0
{count && <p>You have {count} items</p>}

// ✅ Fix: Explicitly check
{count > 0 && <p>You have {count} items</p>}
```

### Logical OR (||) and Nullish Coalescing (??)

For default/fallback values:

```tsx
function Welcome({ name }) {
  return <h1>Hello, {name || 'Guest'}!</h1>;
}

// Nullish coalescing only falls back for null/undefined
function Price({ value }) {
  return <span>${value ?? 'N/A'}</span>;
}
```

### Early Return

Return early to handle edge cases:

```tsx
function UserProfile({ user }) {
  if (!user) {
    return <p>No user found</p>;
  }
  
  if (user.isLoading) {
    return <p>Loading...</p>;
  }
  
  if (user.error) {
    return <p>Error: {user.error}</p>;
  }
  
  // Main render (only reaches here if no issues)
  return (
    <div className="profile">
      <h1>{user.name}</h1>
      <p>{user.email}</p>
    </div>
  );
}
```

### Conditional Classes

```tsx
function Button({ variant, isActive }) {
  return (
    <button 
      className={`btn btn-${variant} ${isActive ? 'active' : ''}`}
    >
      Click me
    </button>
  );
}

// With template literals
function Card({ isSelected }) {
  const classes = `card ${isSelected ? 'card-selected' : 'card-default'}`;
  return <div className={classes}>...</div>;
}
```

### Conditional Styles

```tsx
function Box({ isHighlighted }) {
  return (
    <div 
      style={{
        backgroundColor: isHighlighted ? 'yellow' : 'white',
        padding: '1rem'
      }}
    >
      Content
    </div>
  );
}
```

## Rendering Lists

Use `map()` to transform arrays into lists of elements.

### Basic List

```tsx
function FruitList() {
  const fruits = ['Apple', 'Banana', 'Cherry'];
  
  return (
    <ul>
      {fruits.map(fruit => (
        <li key={fruit}>{fruit}</li>
      ))}
    </ul>
  );
}
```

### List of Objects

```tsx
function UserList({ users }) {
  return (
    <ul>
      {users.map(user => (
        <li key={user.id}>
          {user.name} - {user.email}
        </li>
      ))}
    </ul>
  );
}
```

### Extracting Components

For complex list items, extract a component:

```tsx
function ProductCard({ product }) {
  return (
    <div className="product-card">
      <img src={product.image} alt={product.name} />
      <h3>{product.name}</h3>
      <p>${product.price}</p>
    </div>
  );
}

function ProductGrid({ products }) {
  return (
    <div className="product-grid">
      {products.map(product => (
        <ProductCard key={product.id} product={product} />
      ))}
    </div>
  );
}
```

## The Key Prop

Keys help React identify which items changed, were added, or removed. Every item in a list needs a unique `key` prop.

### Rules for Keys

1. **Unique among siblings** — Keys must be unique within the same list
2. **Stable** — Keys shouldn't change between renders
3. **Not index (usually)** — Using array index can cause bugs

```tsx
// ✅ Good: Unique, stable ID
{users.map(user => (
  <UserCard key={user.id} user={user} />
))}

// ❌ Bad: Index as key (problematic if list order changes)
{users.map((user, index) => (
  <UserCard key={index} user={user} />
))}

// ✅ OK: Index is fine if list is static and never reordered
{staticItems.map((item, index) => (
  <li key={index}>{item}</li>
))}
```

### Why Keys Matter

Without proper keys, React may:
- Inefficiently re-render items
- Lose component state
- Show bugs when reordering lists

```tsx
// Example: This will have bugs if you add items at the beginning
function TodoList() {
  const [todos, setTodos] = useState([
    { text: 'Learn React' },
    { text: 'Build app' }
  ]);
  
  // ❌ Using index - adding to beginning will mess up state
  return todos.map((todo, index) => (
    <TodoItem key={index} todo={todo} />
  ));
}

// ✅ Using unique ID
function TodoList() {
  const [todos, setTodos] = useState([
    { id: 1, text: 'Learn React' },
    { id: 2, text: 'Build app' }
  ]);
  
  return todos.map(todo => (
    <TodoItem key={todo.id} todo={todo} />
  ));
}
```

### Generating Keys

If your data doesn't have IDs, generate them when data is created (not during render):

```tsx
// ✅ Generate ID when creating the item
const addTodo = (text) => {
  setTodos([
    ...todos,
    { id: crypto.randomUUID(), text }
  ]);
};

// ❌ Don't generate during render
{todos.map(todo => (
  <TodoItem key={crypto.randomUUID()} todo={todo} /> // New key every render!
))}
```

## Filtering Lists

Use `filter()` before `map()`:

```tsx
function ActiveUsers({ users }) {
  const activeUsers = users.filter(user => user.isActive);
  
  return (
    <ul>
      {activeUsers.map(user => (
        <li key={user.id}>{user.name}</li>
      ))}
    </ul>
  );
}

// Or inline
function ActiveUsers({ users }) {
  return (
    <ul>
      {users
        .filter(user => user.isActive)
        .map(user => (
          <li key={user.id}>{user.name}</li>
        ))}
    </ul>
  );
}
```

## Sorting Lists

Use `sort()` (remember to copy the array first):

```tsx
function SortedList({ items, sortBy }) {
  const sortedItems = [...items].sort((a, b) => {
    if (sortBy === 'name') {
      return a.name.localeCompare(b.name);
    }
    if (sortBy === 'price') {
      return a.price - b.price;
    }
    return 0;
  });
  
  return (
    <ul>
      {sortedItems.map(item => (
        <li key={item.id}>{item.name} - ${item.price}</li>
      ))}
    </ul>
  );
}
```

## Examples

### Basic Example

```tsx
// components/StatusBadge.tsx
function StatusBadge({ status }) {
  const colors = {
    active: 'green',
    pending: 'yellow',
    inactive: 'gray'
  };
  
  return (
    <span 
      className="badge"
      style={{ backgroundColor: colors[status] || 'gray' }}
    >
      {status}
    </span>
  );
}
```

### Normal Example

```tsx
// components/CommentList.tsx
function Comment({ comment }) {
  return (
    <div className="comment">
      <img src={comment.author.avatar} alt={comment.author.name} />
      <div>
        <strong>{comment.author.name}</strong>
        <p>{comment.text}</p>
        <small>{new Date(comment.createdAt).toLocaleDateString()}</small>
      </div>
    </div>
  );
}

function CommentList({ comments, isLoading }) {
  if (isLoading) {
    return <p>Loading comments...</p>;
  }
  
  if (comments.length === 0) {
    return <p>No comments yet. Be the first to comment!</p>;
  }
  
  return (
    <div className="comment-list">
      {comments.map(comment => (
        <Comment key={comment.id} comment={comment} />
      ))}
    </div>
  );
}
```

### Complex Example

```tsx
// components/DataGrid.tsx
import { useState, useMemo } from 'react';

function DataGrid({ data, columns }) {
  const [sortConfig, setSortConfig] = useState({ key: null, direction: 'asc' });
  const [filterText, setFilterText] = useState('');
  const [selectedIds, setSelectedIds] = useState(new Set());
  
  const processedData = useMemo(() => {
    let result = [...data];
    
    // Filter
    if (filterText) {
      result = result.filter(row =>
        columns.some(col =>
          String(row[col.key]).toLowerCase().includes(filterText.toLowerCase())
        )
      );
    }
    
    // Sort
    if (sortConfig.key) {
      result.sort((a, b) => {
        const aVal = a[sortConfig.key];
        const bVal = b[sortConfig.key];
        
        if (aVal < bVal) return sortConfig.direction === 'asc' ? -1 : 1;
        if (aVal > bVal) return sortConfig.direction === 'asc' ? 1 : -1;
        return 0;
      });
    }
    
    return result;
  }, [data, filterText, sortConfig, columns]);
  
  const handleSort = (key) => {
    setSortConfig(prev => ({
      key,
      direction: prev.key === key && prev.direction === 'asc' ? 'desc' : 'asc'
    }));
  };
  
  const toggleSelect = (id) => {
    setSelectedIds(prev => {
      const newSet = new Set(prev);
      if (newSet.has(id)) {
        newSet.delete(id);
      } else {
        newSet.add(id);
      }
      return newSet;
    });
  };
  
  const toggleSelectAll = () => {
    if (selectedIds.size === processedData.length) {
      setSelectedIds(new Set());
    } else {
      setSelectedIds(new Set(processedData.map(row => row.id)));
    }
  };
  
  return (
    <div className="data-grid">
      <input
        type="text"
        value={filterText}
        onChange={(e) => setFilterText(e.target.value)}
        placeholder="Filter..."
      />
      
      {selectedIds.size > 0 && (
        <p>{selectedIds.size} item(s) selected</p>
      )}
      
      <table>
        <thead>
          <tr>
            <th>
              <input
                type="checkbox"
                checked={selectedIds.size === processedData.length && processedData.length > 0}
                onChange={toggleSelectAll}
              />
            </th>
            {columns.map(col => (
              <th 
                key={col.key}
                onClick={() => handleSort(col.key)}
                style={{ cursor: 'pointer' }}
              >
                {col.label}
                {sortConfig.key === col.key && (
                  <span>{sortConfig.direction === 'asc' ? ' ↑' : ' ↓'}</span>
                )}
              </th>
            ))}
          </tr>
        </thead>
        <tbody>
          {processedData.length === 0 ? (
            <tr>
              <td colSpan={columns.length + 1}>No data found</td>
            </tr>
          ) : (
            processedData.map(row => (
              <tr 
                key={row.id}
                className={selectedIds.has(row.id) ? 'selected' : ''}
              >
                <td>
                  <input
                    type="checkbox"
                    checked={selectedIds.has(row.id)}
                    onChange={() => toggleSelect(row.id)}
                  />
                </td>
                {columns.map(col => (
                  <td key={col.key}>{row[col.key]}</td>
                ))}
              </tr>
            ))
          )}
        </tbody>
      </table>
    </div>
  );
}
```

### Edge Case Example

```tsx
// components/SafeList.tsx
function SafeList({ items, renderItem, emptyMessage = 'No items' }) {
  // Handle null/undefined items
  if (!items) {
    return <p className="empty">{emptyMessage}</p>;
  }
  
  // Handle non-array items
  if (!Array.isArray(items)) {
    console.error('SafeList expected an array, received:', typeof items);
    return <p className="error">Invalid data format</p>;
  }
  
  // Handle empty array
  if (items.length === 0) {
    return <p className="empty">{emptyMessage}</p>;
  }
  
  // Handle items without IDs
  const itemsWithKeys = items.map((item, index) => {
    if (item && typeof item === 'object') {
      return {
        ...item,
        _safeKey: item.id ?? item.key ?? `item-${index}`
      };
    }
    // Primitive values
    return { value: item, _safeKey: `item-${index}` };
  });
  
  return (
    <ul className="safe-list">
      {itemsWithKeys.map(item => (
        <li key={item._safeKey}>
          {renderItem ? renderItem(item) : String(item.value ?? item)}
        </li>
      ))}
    </ul>
  );
}

// Usage
<SafeList 
  items={users} 
  renderItem={(user) => <UserCard user={user} />}
  emptyMessage="No users found"
/>

// Handles these edge cases:
<SafeList items={null} />           // Shows "No items"
<SafeList items={undefined} />      // Shows "No items"
<SafeList items={[]} />             // Shows "No items"
<SafeList items="not an array" />   // Shows error
<SafeList items={[1, 2, 3]} />      // Works with primitives
```

## Combining Conditionals and Lists

Real components often combine both patterns:

```tsx
function TaskList({ tasks, filter, showCompleted }) {
  // Filter based on status
  const filteredTasks = tasks.filter(task => {
    if (filter === 'active') return !task.completed;
    if (filter === 'completed') return task.completed;
    return true; // 'all'
  });
  
  return (
    <div className="task-list">
      {filteredTasks.length === 0 ? (
        <p className="empty">
          {filter === 'completed' 
            ? 'No completed tasks' 
            : 'No tasks to show'}
        </p>
      ) : (
        <ul>
          {filteredTasks.map(task => (
            <li 
              key={task.id}
              className={task.completed ? 'completed' : ''}
            >
              <input 
                type="checkbox" 
                checked={task.completed}
                onChange={() => toggleTask(task.id)}
              />
              <span>{task.text}</span>
              {task.priority === 'high' && (
                <span className="badge">High Priority</span>
              )}
            </li>
          ))}
        </ul>
      )}
      
      {showCompleted && (
        <p className="stats">
          {tasks.filter(t => t.completed).length} of {tasks.length} completed
        </p>
      )}
    </div>
  );
}
```

## Key Takeaways

- Use if statements, ternaries, and && for conditional rendering
- Be careful with falsy values (especially 0) in && conditions
- Use `map()` to render lists of elements
- Every list item needs a unique, stable `key` prop
- Avoid using array index as key when list can change
- Use `filter()` and `sort()` to transform data before rendering
- Extract list items into separate components for cleaner code

## Questions & Answers

### Q: When should I use ternary vs &&?
**A:** Use `&&` when you want to show something or nothing. Use ternary when you have two alternatives to show.

```tsx
// Either show notification OR nothing
{hasNotification && <Notification />}

// Show one thing OR another
{isLoggedIn ? <Dashboard /> : <Login />}
```

### Q: Why does React need keys?
**A:** Keys help React identify which items changed, were added, or removed. Without keys, React can't efficiently update lists and may cause bugs with component state.

### Q: Can I use the same key in different lists?
**A:** Yes. Keys only need to be unique among siblings (items in the same array).

### Q: What happens if I don't provide a key?
**A:** React will warn you in development. It'll use index as a fallback, which can cause bugs if the list changes.

### Q: Should I memoize my filtered/sorted arrays?
**A:** Use `useMemo` if the transformation is expensive or if you're passing the result to memoized children. For simple operations, it's often unnecessary.

### Q: How do I render nested lists?
**A:** Use nested `map()` calls with unique keys at each level:

```tsx
{categories.map(category => (
  <div key={category.id}>
    <h2>{category.name}</h2>
    <ul>
      {category.items.map(item => (
        <li key={item.id}>{item.name}</li>
      ))}
    </ul>
  </div>
))}
```

## Resources

- [React: Conditional Rendering](https://react.dev/learn/conditional-rendering)
- [React: Rendering Lists](https://react.dev/learn/rendering-lists)
- [React: Why does React need keys?](https://react.dev/learn/rendering-lists#why-does-react-need-keys)
- [Kent C. Dodds: Understanding React's key prop](https://kentcdodds.com/blog/understanding-reacts-key-prop)

---

**Next Chapter:** [4. The App Router](./04-app-router.md) - Start learning Next.js-specific features with the file-based routing system.
