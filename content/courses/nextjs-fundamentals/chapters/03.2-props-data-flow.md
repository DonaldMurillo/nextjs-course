# Chapter 3.2: Props & Data Flow

## What Are Props?

Props (short for "properties") are how you pass data from a parent component to a child component. They're the mechanism for component communication and customization.

```tsx
// Parent passes props
<Greeting name="Alice" age={28} />

// Child receives props
function Greeting(props) {
  return <h1>Hello, {props.name}! You are {props.age}.</h1>;
}
```

Think of props like function arguments—they let you configure how a component behaves and what it displays.

## Passing Props

Props can be any TypeScript value: strings, numbers, booleans, objects, arrays, functions, and even other components.

```tsx
// String (quotes for literals)
<Card title="Welcome" />

// Number (curly braces for expressions)
<Card count={42} />

// Boolean (true can be implicit)
<Card featured={true} />
<Card featured />  // Same as featured={true}

// Object
<Card user={{ name: 'Alice', role: 'Admin' }} />

// Array
<Card tags={['react', 'nextjs', 'typescript']} />

// Function
<Card onClick={() => console.log('clicked')} />

// Variable
const data = { title: 'Hello' };
<Card data={data} />
```

## Receiving Props

### Object Parameter (Traditional)

```tsx
function UserCard(props) {
  return (
    <div>
      <h2>{props.name}</h2>
      <p>{props.email}</p>
    </div>
  );
}
```

### Destructuring (Preferred)

```tsx
function UserCard({ name, email }) {
  return (
    <div>
      <h2>{name}</h2>
      <p>{email}</p>
    </div>
  );
}
```

Destructuring is cleaner and makes it immediately clear what props a component expects.

### Destructuring with Rest

```tsx
function Button({ children, className, ...rest }) {
  return (
    <button className={`btn ${className}`} {...rest}>
      {children}
    </button>
  );
}

// Usage: all other props (onClick, disabled, etc.) pass through
<Button className="primary" onClick={handleClick} disabled={isLoading}>
  Click me
</Button>
```

## Default Props

Set default values when props aren't provided.

### Using Default Parameters (Preferred)

```tsx
function Button({ 
  variant = 'primary', 
  size = 'medium',
  children 
}) {
  return (
    <button className={`btn btn-${variant} btn-${size}`}>
      {children}
    </button>
  );
}

// Usage
<Button>Default</Button>                    // variant="primary", size="medium"
<Button variant="secondary">Custom</Button> // variant="secondary", size="medium"
```

### Using defaultProps (Legacy)

```tsx
function Button({ variant, size, children }) {
  return (
    <button className={`btn btn-${variant} btn-${size}`}>
      {children}
    </button>
  );
}

Button.defaultProps = {
  variant: 'primary',
  size: 'medium'
};
```

Default parameters are preferred in modern React.

## The Children Prop

The `children` prop contains whatever you put between a component's opening and closing tags.

```tsx
function Card({ children }) {
  return <div className="card">{children}</div>;
}

// Usage
<Card>
  <h2>Title</h2>
  <p>Some content here</p>
</Card>
```

Children can be anything: text, elements, components, or even functions.

```tsx
// Text
<Button>Click me</Button>

// Multiple elements
<Card>
  <Header />
  <Body />
  <Footer />
</Card>

// Mixed content
<Alert>
  <strong>Warning:</strong> Something went wrong
</Alert>
```

## One-Way Data Flow

React uses **one-way data flow** (also called "unidirectional data flow"). Data flows down from parent to child through props. Children cannot directly modify props—they're read-only.

```
Parent Component
    │
    ├── props ──→ Child Component A
    │
    └── props ──→ Child Component B
                       │
                       └── props ──→ Grandchild Component
```

### Why One-Way?

- **Predictable**: Data changes are easy to trace
- **Debuggable**: You always know where data comes from
- **Maintainable**: Components are self-contained

### What If a Child Needs to Communicate Up?

Pass a function as a prop. The child calls the function, and the parent handles the logic.

```tsx
// Parent
function Parent() {
  const handleMessage = (message) => {
    console.log('Child says:', message);
  };
  
  return <Child onMessage={handleMessage} />;
}

// Child
function Child({ onMessage }) {
  return (
    <button onClick={() => onMessage('Hello from child!')}>
      Send Message
    </button>
  );
}
```

## Examples

### Basic Example

```tsx
// components/Greeting.tsx
function Greeting({ name }) {
  return <p>Hello, {name}!</p>;
}

// Usage
<Greeting name="Alice" />
// Output: Hello, Alice!
```

### Normal Example

```tsx
// components/ProductCard.tsx
function ProductCard({ name, price, inStock, onAddToCart }) {
  return (
    <div className="product-card">
      <h3>{name}</h3>
      <p className="price">${price.toFixed(2)}</p>
      <p className={inStock ? 'in-stock' : 'out-of-stock'}>
        {inStock ? 'In Stock' : 'Out of Stock'}
      </p>
      <button 
        onClick={onAddToCart}
        disabled={!inStock}
      >
        Add to Cart
      </button>
    </div>
  );
}

// Usage
function Shop() {
  const handleAddToCart = () => {
    console.log('Added to cart');
  };
  
  return (
    <ProductCard 
      name="Wireless Headphones"
      price={79.99}
      inStock={true}
      onAddToCart={handleAddToCart}
    />
  );
}
```

### Complex Example

```tsx
// components/DataTable.tsx
function TableHeader({ columns }) {
  return (
    <thead>
      <tr>
        {columns.map(col => (
          <th key={col.key}>{col.label}</th>
        ))}
      </tr>
    </thead>
  );
}

function TableRow({ row, columns, onRowClick }) {
  return (
    <tr onClick={() => onRowClick(row)}>
      {columns.map(col => (
        <td key={col.key}>{row[col.key]}</td>
      ))}
    </tr>
  );
}

function DataTable({ 
  data, 
  columns, 
  onRowClick,
  emptyMessage = 'No data available'
}) {
  if (data.length === 0) {
    return <p className="empty">{emptyMessage}</p>;
  }
  
  return (
    <table className="data-table">
      <TableHeader columns={columns} />
      <tbody>
        {data.map(row => (
          <TableRow 
            key={row.id} 
            row={row} 
            columns={columns}
            onRowClick={onRowClick}
          />
        ))}
      </tbody>
    </table>
  );
}

// Usage
function UserList() {
  const columns = [
    { key: 'name', label: 'Name' },
    { key: 'email', label: 'Email' },
    { key: 'role', label: 'Role' }
  ];
  
  const users = [
    { id: 1, name: 'Alice', email: 'alice@example.com', role: 'Admin' },
    { id: 2, name: 'Bob', email: 'bob@example.com', role: 'User' }
  ];
  
  const handleRowClick = (user) => {
    console.log('Selected:', user.name);
  };
  
  return (
    <DataTable 
      data={users}
      columns={columns}
      onRowClick={handleRowClick}
      emptyMessage="No users found"
    />
  );
}
```

### Edge Case Example

```tsx
// components/SafeImage.tsx
function SafeImage({ 
  src, 
  alt,
  fallback = '/placeholder.png',
  ...props 
}) {
  // Handle undefined/null src
  const imageSrc = src || fallback;
  
  // Handle undefined/null alt (accessibility)
  const imageAlt = alt || '';
  
  return (
    <img
      src={imageSrc}
      alt={imageAlt}
      onError={(e) => {
        // If the image fails to load, use fallback
        if (e.target.src !== fallback) {
          e.target.src = fallback;
        }
      }}
      {...props}
    />
  );
}

// Usage - handles all these cases
<SafeImage src={user.avatar} alt={user.name} />        // Normal
<SafeImage src={null} alt="Profile" />                  // Null src
<SafeImage src={undefined} alt="Profile" />             // Undefined src
<SafeImage src="/broken-link.jpg" alt="Will fail" />    // Broken image
<SafeImage src={user.avatar} />                         // Missing alt
```

## Prop Patterns

### Spread Props

Pass all properties of an object as individual props.

```tsx
const buttonProps = {
  type: 'submit',
  className: 'btn-primary',
  disabled: false
};

// Instead of:
<button 
  type={buttonProps.type}
  className={buttonProps.className}
  disabled={buttonProps.disabled}
>
  Submit
</button>

// Use spread:
<button {...buttonProps}>Submit</button>
```

### Render Props

Pass a function that returns JSX.

```tsx
function MouseTracker({ render }) {
  const [position, setPosition] = useState({ x: 0, y: 0 });
  
  useEffect(() => {
    const handleMove = (e) => {
      setPosition({ x: e.clientX, y: e.clientY });
    };
    window.addEventListener('mousemove', handleMove);
    return () => window.removeEventListener('mousemove', handleMove);
  }, []);
  
  return render(position);
}

// Usage
<MouseTracker 
  render={({ x, y }) => (
    <p>Mouse is at ({x}, {y})</p>
  )}
/>
```

### Composition vs Inheritance

React favors composition over inheritance. Instead of extending components, compose them.

```tsx
// ❌ Don't use inheritance
class SpecialButton extends Button { ... }

// ✅ Use composition
function DangerButton(props) {
  return <Button variant="danger" {...props} />;
}

function IconButton({ icon, children, ...props }) {
  return (
    <Button {...props}>
      <Icon name={icon} />
      {children}
    </Button>
  );
}
```

## Props in Next.js

In Next.js, props work the same way, but there are special considerations:

### Props from Server to Client Components

Server Components can pass props to Client Components, but only serializable data (no functions, classes, or Dates that aren't converted to strings).

```tsx
// app/page.tsx (Server Component)
export default async function Page() {
  const data = await fetchData();
  
  return (
    <ClientComponent 
      items={data.items}           // ✅ Array of plain objects
      count={data.count}           // ✅ Number
      onClick={handleClick}        // ❌ Can't pass functions to client
    />
  );
}
```

### Page Props

Next.js pages receive special props like `params` and `searchParams`.

```tsx
// app/blog/[slug]/page.tsx
export default function BlogPost({ params, searchParams }) {
  // params.slug contains the dynamic segment
  // searchParams contains URL query parameters
  return <article>...</article>;
}
```

## Key Takeaways

- Props are how data flows from parent to child components
- Use destructuring for cleaner prop access
- Set defaults with default parameters
- The `children` prop captures content between component tags
- Data flows one way: parent → child
- Pass functions as props for child-to-parent communication
- Props are read-only—never modify them directly

## Questions & Answers

### Q: Can I modify props?
**A:** No. Props are read-only. If you need to change data based on props, use state or derive new values during rendering.

### Q: What happens if I don't pass a required prop?
**A:** The prop will be `undefined`, which may cause errors or unexpected behavior. Use default values or check for undefined.

### Q: How many props is too many?
**A:** If a component has more than 5-7 props, consider if it's doing too much. You might break it into smaller components or group related props into an object.

### Q: Should I use propTypes?
**A:** PropTypes provide runtime type checking but are largely replaced by TypeScript for type safety. For JavaScript projects without TypeScript, propTypes can still be valuable.

### Q: When should I use children vs named props?
**A:** Use `children` for content that naturally goes "inside" a component (like a Card's body). Use named props for specific, well-defined data (like a Card's title).

### Q: Can I pass components as props?
**A:** Yes! Components can receive other components as props:
```tsx
<Card header={<CustomHeader />} footer={<CustomFooter />}>
  Content
</Card>
```

## Resources

- [React: Passing Props to a Component](https://react.dev/learn/passing-props-to-a-component)
- [React: Component Composition](https://react.dev/learn/passing-props-to-a-component#passing-jsx-as-children)
- [Kent C. Dodds: Prop Drilling](https://kentcdodds.com/blog/prop-drilling)

