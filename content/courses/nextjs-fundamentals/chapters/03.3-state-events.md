# Chapter 3.3: State & Event Handling

## What Is State?

State is data that changes over time and affects what your component renders. When state changes, React re-renders the component to reflect the new data.

Props are data passed *into* a component (from outside). State is data managed *within* a component (internal).

```tsx
// Props: data from parent (external)
function Greeting({ name }) {
  return <h1>Hello, {name}</h1>;
}

// State: data managed internally
function Counter() {
  const [count, setCount] = useState(0);
  return <button onClick={() => setCount(count + 1)}>{count}</button>;
}
```

## useState Hook

The `useState` hook lets you add state to function components.

```tsx
import { useState } from 'react';

function Counter() {
  // Declare state variable "count" with initial value 0
  // setCount is the function to update it
  const [count, setCount] = useState(0);
  
  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
}
```

### Anatomy of useState

```tsx
const [stateValue, setStateFunction] = useState(initialValue);
```

- **stateValue**: Current value of the state
- **setStateFunction**: Function to update the state (convention: `set` + variable name)
- **initialValue**: The starting value (can be any type)

### State Can Be Any Type

```tsx
// Number
const [count, setCount] = useState(0);

// String
const [name, setName] = useState('');

// Boolean
const [isOpen, setIsOpen] = useState(false);

// Object
const [user, setUser] = useState({ name: '', email: '' });

// Array
const [items, setItems] = useState([]);

// Null
const [data, setData] = useState(null);
```

### Updating State

Always use the setter function—never modify state directly.

```tsx
// ❌ Wrong: Direct mutation
count = count + 1;

// ✅ Correct: Use setter
setCount(count + 1);
```

### Functional Updates

When new state depends on previous state, use a function:

```tsx
// ❌ May cause issues with stale state
setCount(count + 1);

// ✅ Guaranteed to use latest state
setCount(prevCount => prevCount + 1);
```

This is especially important in async operations or when updating state multiple times quickly.

### Updating Objects

When state is an object, you must create a new object (spread the old one, then override):

```tsx
const [user, setUser] = useState({ name: 'Alice', email: 'alice@example.com' });

// ❌ Wrong: Mutating existing object
user.name = 'Bob';
setUser(user);

// ✅ Correct: Create new object
setUser({ ...user, name: 'Bob' });

// ✅ Also correct: Functional update
setUser(prevUser => ({ ...prevUser, name: 'Bob' }));
```

### Updating Arrays

Similarly, create a new array:

```tsx
const [items, setItems] = useState(['apple', 'banana']);

// Adding an item
setItems([...items, 'cherry']);

// Removing an item
setItems(items.filter(item => item !== 'banana'));

// Updating an item
setItems(items.map(item => 
  item === 'apple' ? 'green apple' : item
));
```

## Event Handling

React uses camelCase event names and passes functions (not strings).

```tsx
// HTML
<button onclick="handleClick()">Click</button>

// React
<button onClick={handleClick}>Click</button>
```

### Basic Event Handling

```tsx
function Button() {
  const handleClick = () => {
    console.log('Button clicked!');
  };
  
  return <button onClick={handleClick}>Click me</button>;
}
```

### Inline Handlers

For simple operations, inline arrow functions work fine:

```tsx
<button onClick={() => console.log('clicked')}>Click</button>
<button onClick={() => setCount(count + 1)}>Increment</button>
```

### Event Object

Event handlers receive an event object with information about the event:

```tsx
function Form() {
  const handleSubmit = (event) => {
    event.preventDefault(); // Prevent form submission
    console.log('Form submitted');
  };
  
  const handleChange = (event) => {
    console.log('Input value:', event.target.value);
  };
  
  return (
    <form onSubmit={handleSubmit}>
      <input onChange={handleChange} />
      <button type="submit">Submit</button>
    </form>
  );
}
```

### Passing Arguments to Handlers

Use an arrow function to pass additional arguments:

```tsx
function ItemList() {
  const handleDelete = (id) => {
    console.log('Deleting item:', id);
  };
  
  return (
    <ul>
      {items.map(item => (
        <li key={item.id}>
          {item.name}
          <button onClick={() => handleDelete(item.id)}>Delete</button>
        </li>
      ))}
    </ul>
  );
}
```

### Common Events

| Event | Description |
|-------|-------------|
| `onClick` | Click (mouse or keyboard) |
| `onChange` | Input value changes |
| `onSubmit` | Form submission |
| `onFocus` | Element receives focus |
| `onBlur` | Element loses focus |
| `onKeyDown` | Key pressed down |
| `onKeyUp` | Key released |
| `onMouseEnter` | Mouse enters element |
| `onMouseLeave` | Mouse leaves element |

## Controlled Components

In controlled components, React state is the "single source of truth" for input values.

```tsx
function ControlledInput() {
  const [value, setValue] = useState('');
  
  return (
    <input 
      value={value}
      onChange={(e) => setValue(e.target.value)}
    />
  );
}
```

The input's value always reflects the state, and changes update the state.

### Why Controlled?

- **Validation**: Validate or transform input before accepting
- **Conditional logic**: React to changes immediately
- **Consistent state**: The UI always matches your data

### Controlled Form Example

```tsx
function ContactForm() {
  const [formData, setFormData] = useState({
    name: '',
    email: '',
    message: ''
  });
  
  const handleChange = (e) => {
    const { name, value } = e.target;
    setFormData(prev => ({
      ...prev,
      [name]: value
    }));
  };
  
  const handleSubmit = (e) => {
    e.preventDefault();
    console.log('Submitting:', formData);
  };
  
  return (
    <form onSubmit={handleSubmit}>
      <input
        name="name"
        value={formData.name}
        onChange={handleChange}
        placeholder="Name"
      />
      <input
        name="email"
        type="email"
        value={formData.email}
        onChange={handleChange}
        placeholder="Email"
      />
      <textarea
        name="message"
        value={formData.message}
        onChange={handleChange}
        placeholder="Message"
      />
      <button type="submit">Send</button>
    </form>
  );
}
```

## Examples

### Basic Example

```tsx
// components/Toggle.tsx
import { useState } from 'react';

function Toggle() {
  const [isOn, setIsOn] = useState(false);
  
  return (
    <button onClick={() => setIsOn(!isOn)}>
      {isOn ? 'ON' : 'OFF'}
    </button>
  );
}
```

### Normal Example

```tsx
// components/TodoInput.tsx
import { useState } from 'react';

function TodoInput({ onAdd }) {
  const [text, setText] = useState('');
  
  const handleSubmit = (e) => {
    e.preventDefault();
    if (text.trim()) {
      onAdd(text.trim());
      setText(''); // Clear input after adding
    }
  };
  
  return (
    <form onSubmit={handleSubmit} className="todo-input">
      <input
        value={text}
        onChange={(e) => setText(e.target.value)}
        placeholder="Add a todo..."
      />
      <button type="submit" disabled={!text.trim()}>
        Add
      </button>
    </form>
  );
}
```

### Complex Example

```tsx
// components/ShoppingCart.tsx
import { useState } from 'react';

function ShoppingCart() {
  const [items, setItems] = useState([
    { id: 1, name: 'Shirt', price: 25, quantity: 1 },
    { id: 2, name: 'Pants', price: 40, quantity: 2 }
  ]);
  
  const updateQuantity = (id, delta) => {
    setItems(prevItems => 
      prevItems.map(item => {
        if (item.id === id) {
          const newQuantity = Math.max(0, item.quantity + delta);
          return { ...item, quantity: newQuantity };
        }
        return item;
      }).filter(item => item.quantity > 0) // Remove if quantity is 0
    );
  };
  
  const removeItem = (id) => {
    setItems(prevItems => prevItems.filter(item => item.id !== id));
  };
  
  const total = items.reduce(
    (sum, item) => sum + item.price * item.quantity, 
    0
  );
  
  return (
    <div className="cart">
      <h2>Shopping Cart</h2>
      {items.length === 0 ? (
        <p>Your cart is empty</p>
      ) : (
        <>
          <ul>
            {items.map(item => (
              <li key={item.id} className="cart-item">
                <span>{item.name}</span>
                <span>${item.price}</span>
                <div className="quantity-controls">
                  <button onClick={() => updateQuantity(item.id, -1)}>-</button>
                  <span>{item.quantity}</span>
                  <button onClick={() => updateQuantity(item.id, 1)}>+</button>
                </div>
                <button onClick={() => removeItem(item.id)}>Remove</button>
              </li>
            ))}
          </ul>
          <p className="total">Total: ${total.toFixed(2)}</p>
        </>
      )}
    </div>
  );
}
```

### Edge Case Example

```tsx
// components/DebouncedSearch.tsx
import { useState, useEffect } from 'react';

function DebouncedSearch({ onSearch }) {
  const [query, setQuery] = useState('');
  const [debouncedQuery, setDebouncedQuery] = useState('');
  
  // Debounce the query
  useEffect(() => {
    const timer = setTimeout(() => {
      setDebouncedQuery(query);
    }, 300);
    
    return () => clearTimeout(timer);
  }, [query]);
  
  // Trigger search when debounced query changes
  useEffect(() => {
    if (debouncedQuery) {
      onSearch(debouncedQuery);
    }
  }, [debouncedQuery, onSearch]);
  
  const handleChange = (e) => {
    const value = e.target.value;
    // Sanitize input: remove special characters that might break search
    const sanitized = value.replace(/[<>{}]/g, '');
    setQuery(sanitized);
  };
  
  const handleClear = () => {
    setQuery('');
    setDebouncedQuery('');
    onSearch('');
  };
  
  return (
    <div className="search-container">
      <input
        type="search"
        value={query}
        onChange={handleChange}
        placeholder="Search..."
      />
      {query && (
        <button 
          type="button" 
          onClick={handleClear}
          className="clear-button"
        >
          ×
        </button>
      )}
    </div>
  );
}
```

## State Management Patterns

### Multiple useState Calls

Use separate useState calls for unrelated state:

```tsx
function Form() {
  const [name, setName] = useState('');
  const [email, setEmail] = useState('');
  const [isSubmitting, setIsSubmitting] = useState(false);
  
  // ...
}
```

### Grouped State

Group related state in an object:

```tsx
function Form() {
  const [formData, setFormData] = useState({
    name: '',
    email: '',
    message: ''
  });
  
  // ...
}
```

### Derived State

Don't store what you can calculate:

```tsx
function Cart() {
  const [items, setItems] = useState([]);
  
  // ❌ Don't store derived values
  // const [total, setTotal] = useState(0);
  
  // ✅ Calculate during render
  const total = items.reduce((sum, item) => sum + item.price, 0);
  const itemCount = items.length;
  
  // ...
}
```

## Key Takeaways

- State is internal data that can change and triggers re-renders
- `useState` returns `[value, setValue]`—always use the setter
- Never mutate state directly; create new values
- Use functional updates when new state depends on previous state
- Event handlers use camelCase (`onClick`, `onChange`)
- Controlled components tie input values to state
- Derive values when possible instead of storing them

## Questions & Answers

### Q: When should I use state vs props?
**A:** Use props for data passed from a parent. Use state for data the component owns and manages itself—typically data that changes due to user interaction.

### Q: Why does my state seem one step behind?
**A:** State updates are asynchronous. The new value isn't available until the next render. Use functional updates or useEffect to respond to changes.

```tsx
// State won't be updated immediately
setCount(count + 1);
console.log(count); // Still the old value!
```

### Q: Can I have multiple useState in one component?
**A:** Yes! Use as many as needed. It's often cleaner than one large object:
```tsx
const [name, setName] = useState('');
const [age, setAge] = useState(0);
const [isActive, setIsActive] = useState(false);
```

### Q: Why do I need to spread objects/arrays when updating?
**A:** React uses reference equality to detect changes. If you mutate an existing object, React doesn't know it changed. Spreading creates a new reference.

### Q: What's the difference between `onClick={handleClick}` and `onClick={() => handleClick()}`?
**A:** The first passes the function reference directly. The second creates a new arrow function that calls handleClick. Use the second when you need to pass arguments:
```tsx
onClick={() => handleClick(id)}
```

### Q: Should I always use controlled components?
**A:** For most cases, yes. Uncontrolled components (using refs) are useful for file inputs or when integrating with non-React code, but controlled components give you more control and predictability.

## Resources

- [React: State - A Component's Memory](https://react.dev/learn/state-a-components-memory)
- [React: Responding to Events](https://react.dev/learn/responding-to-events)
- [React: Updating Objects in State](https://react.dev/learn/updating-objects-in-state)
- [React: Updating Arrays in State](https://react.dev/learn/updating-arrays-in-state)

