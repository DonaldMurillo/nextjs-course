# Chapter 8.1: Server Actions Basics

## Overview

Server Actions are the foundation of mutations in Next.js. This chapter covers how to create actions, pass data to them, and use them in forms and components.

## Creating Server Actions

### File-Level Directive

Mark an entire file as server-only:

```tsx
// app/actions.ts
"use server";

// All exports are Server Actions
export async function createUser(formData) {
  // Runs on server
}

export async function updateUser(formData) {
  // Runs on server
}
```

### Function-Level Directive

Mark individual functions inside Server Components:

```tsx
// app/page.tsx (Server Component)
export default function Page() {
  async function submitForm(formData) {
    "use server";  // This function runs on server
    
    const name = formData.get('name');
    await db.users.create({ data: { name } });
  }
  
  return (
    <form action={submitForm}>
      <input name="name" />
      <button type="submit">Submit</button>
    </form>
  );
}
```

## Using with Forms

### Basic Form Submission

```tsx
// app/actions.ts
"use server";

import { revalidatePath } from 'next/cache';

export async function addTodo(formData) {
  const text = formData.get('text');
  
  await db.todos.create({
    data: { text, completed: false }
  });
  
  revalidatePath('/todos');
}
```

```tsx
// app/todos/page.tsx
import { addTodo } from '@/app/actions';

export default function TodosPage() {
  return (
    <form action={addTodo}>
      <input name="text" placeholder="Add todo..." required />
      <button type="submit">Add</button>
    </form>
  );
}
```

### Multiple Form Fields

```tsx
// app/actions.ts
"use server";

export async function createPost(formData) {
  const title = formData.get('title');
  const content = formData.get('content');
  const category = formData.get('category');
  const tags = formData.getAll('tags');  // For multiple values
  const isPublished = formData.get('published') === 'on';
  
  await db.posts.create({
    data: {
      title,
      content,
      category,
      tags,
      published: isPublished,
    }
  });
  
  revalidatePath('/posts');
  redirect('/posts');
}
```

```tsx
// app/posts/new/page.tsx
import { createPost } from '@/app/actions';

export default function NewPostPage() {
  return (
    <form action={createPost}>
      <input name="title" placeholder="Title" required />
      
      <textarea name="content" placeholder="Content" required />
      
      <select name="category">
        <option value="tech">Tech</option>
        <option value="lifestyle">Lifestyle</option>
      </select>
      
      <fieldset>
        <legend>Tags</legend>
        <label>
          <input type="checkbox" name="tags" value="react" /> React
        </label>
        <label>
          <input type="checkbox" name="tags" value="nextjs" /> Next.js
        </label>
      </fieldset>
      
      <label>
        <input type="checkbox" name="published" /> Publish immediately
      </label>
      
      <button type="submit">Create Post</button>
    </form>
  );
}
```

## Passing Additional Arguments

### Using bind

Pass extra arguments using `bind`:

```tsx
// app/actions.ts
"use server";

export async function updateItem(itemId, formData) {
  const name = formData.get('name');
  
  await db.items.update({
    where: { id: itemId },
    data: { name }
  });
  
  revalidatePath('/items');
}
```

```tsx
// app/items/[id]/edit/page.tsx
import { updateItem } from '@/app/actions';

export default async function EditItemPage({ params }) {
  const { id } = await params;
  const item = await getItem(id);
  
  // Bind the item ID to the action
  const updateItemWithId = updateItem.bind(null, id);
  
  return (
    <form action={updateItemWithId}>
      <input name="name" defaultValue={item.name} />
      <button type="submit">Update</button>
    </form>
  );
}
```

### Using Hidden Inputs

Alternative approach with hidden fields:

```tsx
<form action={updateItem}>
  <input type="hidden" name="itemId" value={item.id} />
  <input name="name" defaultValue={item.name} />
  <button type="submit">Update</button>
</form>
```

```tsx
// app/actions.ts
"use server";

export async function updateItem(formData) {
  const itemId = formData.get('itemId');
  const name = formData.get('name');
  
  await db.items.update({
    where: { id: itemId },
    data: { name }
  });
}
```

## Calling Actions from Client Components

### As Event Handlers

```tsx
// components/LikeButton.tsx
"use client";

import { likePost } from '@/app/actions';

export function LikeButton({ postId }) {
  const handleLike = async () => {
    await likePost(postId);
  };
  
  return (
    <button onClick={handleLike}>
      ❤️ Like
    </button>
  );
}
```

```tsx
// app/actions.ts
"use server";

export async function likePost(postId) {
  await db.posts.update({
    where: { id: postId },
    data: { likes: { increment: 1 } }
  });
  
  revalidatePath('/posts');
}
```

### With Transitions

Use `useTransition` for pending states:

```tsx
// components/DeleteButton.tsx
"use client";

import { useTransition } from 'react';
import { deletePost } from '@/app/actions';

export function DeleteButton({ postId }) {
  const [isPending, startTransition] = useTransition();
  
  const handleDelete = () => {
    startTransition(async () => {
      await deletePost(postId);
    });
  };
  
  return (
    <button onClick={handleDelete} disabled={isPending}>
      {isPending ? 'Deleting...' : 'Delete'}
    </button>
  );
}
```

## Return Values

Actions can return data to the caller:

```tsx
// app/actions.ts
"use server";

export async function createUser(formData) {
  const email = formData.get('email');
  
  // Check if user exists
  const existing = await db.users.findUnique({ where: { email } });
  
  if (existing) {
    return { error: 'User already exists' };
  }
  
  const user = await db.users.create({
    data: { email }
  });
  
  return { success: true, userId: user.id };
}
```

```tsx
// components/SignupForm.tsx
"use client";

import { createUser } from '@/app/actions';

export function SignupForm() {
  const handleSubmit = async (formData) => {
    const result = await createUser(formData);
    
    if (result.error) {
      alert(result.error);
    } else {
      // Redirect or show success
    }
  };
  
  return (
    <form action={handleSubmit}>
      <input name="email" type="email" required />
      <button type="submit">Sign Up</button>
    </form>
  );
}
```

## Examples

### Basic Example: Simple Todo

```tsx
// app/actions.ts
"use server";

import { revalidatePath } from 'next/cache';

export async function addTodo(formData) {
  const text = formData.get('text');
  await db.todos.create({ data: { text } });
  revalidatePath('/');
}

export async function toggleTodo(id) {
  const todo = await db.todos.findUnique({ where: { id } });
  await db.todos.update({
    where: { id },
    data: { completed: !todo.completed }
  });
  revalidatePath('/');
}
```

```tsx
// app/page.tsx
import { addTodo, toggleTodo } from './actions';

export default async function Home() {
  const todos = await db.todos.findMany();
  
  return (
    <div>
      <form action={addTodo}>
        <input name="text" required />
        <button>Add</button>
      </form>
      
      <ul>
        {todos.map(todo => (
          <li key={todo.id}>
            <form action={toggleTodo.bind(null, todo.id)}>
              <button>{todo.completed ? '✓' : '○'}</button>
            </form>
            {todo.text}
          </li>
        ))}
      </ul>
    </div>
  );
}
```

### Normal Example: Contact Form

```tsx
// app/actions.ts
"use server";

import { z } from 'zod';

const ContactSchema = z.object({
  name: z.string().min(2),
  email: z.string().email(),
  message: z.string().min(10),
});

export async function submitContact(formData) {
  const data = {
    name: formData.get('name'),
    email: formData.get('email'),
    message: formData.get('message'),
  };
  
  // Validate
  const result = ContactSchema.safeParse(data);
  
  if (!result.success) {
    return {
      success: false,
      errors: result.error.flatten().fieldErrors,
    };
  }
  
  // Save to database
  await db.contacts.create({ data });
  
  // Send email notification
  await sendEmail({
    to: 'admin@example.com',
    subject: `New contact from ${data.name}`,
    body: data.message,
  });
  
  return { success: true };
}
```

```tsx
// app/contact/page.tsx
import { submitContact } from '@/app/actions';
import { ContactForm } from '@/components/ContactForm';

export default function ContactPage() {
  return (
    <div>
      <h1>Contact Us</h1>
      <ContactForm action={submitContact} />
    </div>
  );
}

// components/ContactForm.tsx
"use client";

import { useActionState } from 'react';

export function ContactForm({ action }) {
  const [state, formAction] = useActionState(action, null);
  
  return (
    <form action={formAction}>
      <div>
        <input name="name" placeholder="Name" required />
        {state?.errors?.name && <p className="error">{state.errors.name}</p>}
      </div>
      
      <div>
        <input name="email" type="email" placeholder="Email" required />
        {state?.errors?.email && <p className="error">{state.errors.email}</p>}
      </div>
      
      <div>
        <textarea name="message" placeholder="Message" required />
        {state?.errors?.message && <p className="error">{state.errors.message}</p>}
      </div>
      
      <button type="submit">Send</button>
      
      {state?.success && <p className="success">Message sent!</p>}
    </form>
  );
}
```

### Complex Example: Multi-Step Form

```tsx
// app/actions.ts
"use server";

import { cookies } from 'next/headers';
import { redirect } from 'next/navigation';

export async function saveStep1(formData) {
  const data = {
    name: formData.get('name'),
    email: formData.get('email'),
  };
  
  // Store in cookie for next step
  const cookieStore = await cookies();
  cookieStore.set('onboarding_step1', JSON.stringify(data));
  
  redirect('/onboarding/step-2');
}

export async function saveStep2(formData) {
  const data = {
    company: formData.get('company'),
    role: formData.get('role'),
  };
  
  const cookieStore = await cookies();
  cookieStore.set('onboarding_step2', JSON.stringify(data));
  
  redirect('/onboarding/step-3');
}

export async function completeOnboarding(formData) {
  const cookieStore = await cookies();
  
  // Gather all steps
  const step1 = JSON.parse(cookieStore.get('onboarding_step1')?.value || '{}');
  const step2 = JSON.parse(cookieStore.get('onboarding_step2')?.value || '{}');
  const step3 = {
    plan: formData.get('plan'),
  };
  
  // Create user with all data
  const user = await db.users.create({
    data: {
      ...step1,
      ...step2,
      ...step3,
    }
  });
  
  // Clear cookies
  cookieStore.delete('onboarding_step1');
  cookieStore.delete('onboarding_step2');
  
  redirect('/dashboard');
}
```

### Edge Case Example: File Upload

```tsx
// app/actions.ts
"use server";

import { writeFile } from 'fs/promises';
import { join } from 'path';

export async function uploadFile(formData) {
  const file = formData.get('file');
  
  if (!file) {
    return { error: 'No file provided' };
  }
  
  // Validate file type
  const allowedTypes = ['image/jpeg', 'image/png', 'image/gif'];
  if (!allowedTypes.includes(file.type)) {
    return { error: 'Invalid file type' };
  }
  
  // Validate file size (5MB max)
  if (file.size > 5 * 1024 * 1024) {
    return { error: 'File too large' };
  }
  
  // Generate unique filename
  const bytes = await file.arrayBuffer();
  const buffer = Buffer.from(bytes);
  const filename = `${Date.now()}-${file.name}`;
  const path = join(process.cwd(), 'public', 'uploads', filename);
  
  await writeFile(path, buffer);
  
  // Save to database
  const upload = await db.uploads.create({
    data: {
      filename,
      mimetype: file.type,
      size: file.size,
      url: `/uploads/${filename}`,
    }
  });
  
  revalidatePath('/uploads');
  
  return { success: true, url: upload.url };
}
```

```tsx
// components/FileUpload.tsx
"use client";

import { useState } from 'react';
import { uploadFile } from '@/app/actions';

export function FileUpload() {
  const [preview, setPreview] = useState(null);
  const [uploading, setUploading] = useState(false);
  
  const handleSubmit = async (formData) => {
    setUploading(true);
    const result = await uploadFile(formData);
    setUploading(false);
    
    if (result.error) {
      alert(result.error);
    } else {
      setPreview(result.url);
    }
  };
  
  return (
    <form action={handleSubmit}>
      <input 
        type="file" 
        name="file" 
        accept="image/*"
        onChange={(e) => {
          const file = e.target.files[0];
          if (file) {
            setPreview(URL.createObjectURL(file));
          }
        }}
      />
      {preview && <img src={preview} alt="Preview" width={200} />}
      <button type="submit" disabled={uploading}>
        {uploading ? 'Uploading...' : 'Upload'}
      </button>
    </form>
  );
}
```

## Key Takeaways

- Use `"use server"` at file or function level
- Actions receive `FormData` as first argument
- Use `.bind()` to pass additional arguments
- Call `revalidatePath`/`revalidateTag` to update cached data
- Actions can return serializable data
- Works without JavaScript (progressive enhancement)

## Questions & Answers

### Q: Can I call multiple actions from one form?
**A:** No, a form has one action. Use different submit buttons with formAction, or combine logic in one action.

### Q: How do I show loading states?
**A:** Use `useFormStatus` hook or `useTransition`. See Chapter 8.2.

### Q: Are Server Actions secure?
**A:** They're endpoints—treat them like API routes. Always validate input and check authorization.

### Q: Can I use actions for GET requests?
**A:** Actions are for mutations (POST). For data fetching, use Server Components or Route Handlers.

## Resources

- [Next.js: Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations)
- [React: useActionState](https://react.dev/reference/react/useActionState)
- [MDN: FormData](https://developer.mozilla.org/en-US/docs/Web/API/FormData)

---

**Next:** [8.2 Form Handling & Validation](./08.2-form-handling-validation.md) - Learn advanced form patterns with hooks.
