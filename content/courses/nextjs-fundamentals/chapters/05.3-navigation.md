# Chapter 5.3: Navigation

## Overview

Navigation in Next.js happens through the `Link` component for declarative linking, the `useRouter` hook for programmatic navigation, and the `redirect` function for server-side redirects. Understanding when to use each is key to building smooth user experiences.

## The Link Component

`Link` is Next.js's built-in component for client-side navigation. It prefetches pages in the viewport and enables instant navigation.

### Basic Usage

```tsx
import Link from 'next/link';

function Navigation() {
  return (
    <nav>
      <Link href="/">Home</Link>
      <Link href="/about">About</Link>
      <Link href="/contact">Contact</Link>
    </nav>
  );
}
```

### Dynamic Routes

```tsx
<Link href={`/blog/${post.slug}`}>Read More</Link>

// Or with an object
<Link 
  href={{
    pathname: '/blog/[slug]',
    query: { slug: post.slug }
  }}
>
  Read More
</Link>
```

### With Query Parameters

```tsx
// String format
<Link href="/search?q=nextjs&page=1">Search</Link>

// Object format
<Link 
  href={{
    pathname: '/search',
    query: { q: 'nextjs', page: 1 }
  }}
>
  Search
</Link>
```

### Link Props

| Prop | Type | Description |
|------|------|-------------|
| `href` | string \| object | Required. The path to navigate to |
| `replace` | boolean | Replace history instead of push |
| `scroll` | boolean | Scroll to top after navigation (default: true) |
| `prefetch` | boolean | Prefetch the page (default: true) |

```tsx
// Replace current history entry
<Link href="/login" replace>Login</Link>

// Don't scroll to top
<Link href="/section#reviews" scroll={false}>Reviews</Link>

// Disable prefetching
<Link href="/heavy-page" prefetch={false}>Heavy Page</Link>
```

### Styling Active Links

Create a component that knows when it's active:

```tsx
// components/NavLink.tsx
'use client';

import Link from 'next/link';
import { usePathname } from 'next/navigation';

export function NavLink({ href, children, ...props }) {
  const pathname = usePathname();
  const isActive = pathname === href;
  
  return (
    <Link 
      href={href} 
      className={isActive ? 'nav-link active' : 'nav-link'}
      aria-current={isActive ? 'page' : undefined}
      {...props}
    >
      {children}
    </Link>
  );
}
```

### Styling the Link Itself

`Link` renders an `<a>` tag. Style it directly or wrap content:

```tsx
// Direct styling
<Link href="/about" className="text-blue-500 hover:underline">
  About
</Link>

// With Tailwind
<Link 
  href="/contact" 
  className="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700"
>
  Contact Us
</Link>
```

## The useRouter Hook

For programmatic navigation in Client Components:

```tsx
'use client';

import { useRouter } from 'next/navigation';

function LoginForm() {
  const router = useRouter();
  
  const handleSubmit = async (e) => {
    e.preventDefault();
    const success = await login();
    
    if (success) {
      router.push('/dashboard');
    }
  };
  
  return <form onSubmit={handleSubmit}>...</form>;
}
```

### Router Methods

```tsx
const router = useRouter();

// Navigate to a page (adds to history)
router.push('/dashboard');

// Navigate without adding to history
router.replace('/login');

// Go back in history
router.back();

// Go forward in history
router.forward();

// Refresh the current route (re-fetch data)
router.refresh();

// Prefetch a route
router.prefetch('/heavy-page');
```

### Navigation with Query Params

```tsx
// Simple query
router.push('/search?q=nextjs');

// Building query string
const params = new URLSearchParams({ q: 'nextjs', page: '1' });
router.push(`/search?${params}`);

// Preserving existing params
const searchParams = new URLSearchParams(window.location.search);
searchParams.set('page', '2');
router.push(`/search?${searchParams}`);
```

### Replace vs Push

```tsx
// Push: User can go back
router.push('/step-2');
// History: [/step-1] → [/step-1, /step-2]

// Replace: Replaces current entry
router.replace('/step-2');
// History: [/step-1] → [/step-2]
```

Use `replace` for:
- Redirects after form submission
- Filtering/sorting that shouldn't create history entries
- Authentication redirects

## The redirect Function

For server-side redirects in Server Components, Route Handlers, and Server Actions:

```tsx
// app/dashboard/page.tsx
import { redirect } from 'next/navigation';
import { getUser } from '@/lib/auth';

export default async function Dashboard() {
  const user = await getUser();
  
  if (!user) {
    redirect('/login');
  }
  
  return <h1>Welcome, {user.name}</h1>;
}
```

### In Server Actions

```tsx
// app/actions.ts
'use server';

import { redirect } from 'next/navigation';

export async function createPost(formData) {
  const post = await db.posts.create({
    data: {
      title: formData.get('title'),
      content: formData.get('content'),
    },
  });
  
  redirect(`/blog/${post.slug}`);
}
```

### In Route Handlers

```tsx
// app/api/login/route.ts
import { redirect } from 'next/navigation';

export async function POST(request) {
  const success = await authenticate(request);
  
  if (success) {
    redirect('/dashboard');
  }
  
  return Response.json({ error: 'Invalid credentials' }, { status: 401 });
}
```

### permanentRedirect

For permanent (308) redirects:

```tsx
import { permanentRedirect } from 'next/navigation';

// Old URL structure to new
export default function OldPage() {
  permanentRedirect('/new-page');
}
```

## URL Reading Hooks

### usePathname

Get the current pathname:

```tsx
'use client';

import { usePathname } from 'next/navigation';

function Breadcrumbs() {
  const pathname = usePathname();
  // pathname = '/blog/my-post'
  
  const segments = pathname.split('/').filter(Boolean);
  
  return (
    <nav>
      <a href="/">Home</a>
      {segments.map((segment, index) => {
        const path = '/' + segments.slice(0, index + 1).join('/');
        return (
          <span key={path}>
            {' / '}
            <a href={path}>{segment}</a>
          </span>
        );
      })}
    </nav>
  );
}
```

### useSearchParams

Get URL query parameters:

```tsx
'use client';

import { useSearchParams } from 'next/navigation';

function SearchFilters() {
  const searchParams = useSearchParams();
  
  const query = searchParams.get('q');        // 'nextjs'
  const page = searchParams.get('page');       // '1'
  const tags = searchParams.getAll('tag');     // ['react', 'tutorial']
  
  return (
    <div>
      <p>Searching for: {query}</p>
      <p>Page: {page}</p>
    </div>
  );
}
```

### useParams

Get dynamic route parameters:

```tsx
'use client';

import { useParams } from 'next/navigation';

// In app/blog/[slug]/page.tsx
function BlogPostClient() {
  const params = useParams();
  const slug = params.slug; // 'my-post'
  
  return <p>Current post: {slug}</p>;
}
```

### Combining Hooks

```tsx
'use client';

import { usePathname, useSearchParams, useRouter } from 'next/navigation';

function Pagination({ totalPages }) {
  const router = useRouter();
  const pathname = usePathname();
  const searchParams = useSearchParams();
  
  const currentPage = parseInt(searchParams.get('page') || '1', 10);
  
  const goToPage = (page) => {
    const params = new URLSearchParams(searchParams);
    params.set('page', page.toString());
    router.push(`${pathname}?${params}`);
  };
  
  return (
    <div className="pagination">
      <button 
        onClick={() => goToPage(currentPage - 1)}
        disabled={currentPage <= 1}
      >
        Previous
      </button>
      <span>Page {currentPage} of {totalPages}</span>
      <button 
        onClick={() => goToPage(currentPage + 1)}
        disabled={currentPage >= totalPages}
      >
        Next
      </button>
    </div>
  );
}
```

## Scroll Behavior

### Default Behavior

By default, Next.js scrolls to the top on navigation and restores scroll position on back/forward.

### Disabling Scroll

```tsx
// Don't scroll on this link
<Link href="/page" scroll={false}>No Scroll</Link>

// Don't scroll with router
router.push('/page', { scroll: false });
```

### Scrolling to Hash

```tsx
// Scroll to element with id="reviews"
<Link href="/product#reviews">See Reviews</Link>

// Or programmatically
router.push('/product#reviews');
```

### Custom Scroll Behavior

```tsx
'use client';

import { useEffect } from 'react';
import { usePathname } from 'next/navigation';

export function ScrollToTop() {
  const pathname = usePathname();
  
  useEffect(() => {
    window.scrollTo({ top: 0, behavior: 'smooth' });
  }, [pathname]);
  
  return null;
}
```

## Examples

### Basic Example: Simple Navigation

```tsx
// components/Header.tsx
import Link from 'next/link';

export function Header() {
  return (
    <header>
      <Link href="/" className="logo">MySite</Link>
      <nav>
        <Link href="/products">Products</Link>
        <Link href="/about">About</Link>
        <Link href="/contact">Contact</Link>
      </nav>
    </header>
  );
}
```

### Normal Example: Search with Filters

```tsx
// components/SearchPage.tsx
'use client';

import { useRouter, useSearchParams, usePathname } from 'next/navigation';
import { useState, useTransition } from 'react';

export function SearchPage({ results }) {
  const router = useRouter();
  const pathname = usePathname();
  const searchParams = useSearchParams();
  const [isPending, startTransition] = useTransition();
  
  const [query, setQuery] = useState(searchParams.get('q') || '');
  
  const updateSearch = (updates) => {
    const params = new URLSearchParams(searchParams);
    
    Object.entries(updates).forEach(([key, value]) => {
      if (value) {
        params.set(key, value);
      } else {
        params.delete(key);
      }
    });
    
    // Reset to page 1 when filters change
    if (!updates.page) {
      params.delete('page');
    }
    
    startTransition(() => {
      router.push(`${pathname}?${params}`);
    });
  };
  
  const handleSubmit = (e) => {
    e.preventDefault();
    updateSearch({ q: query });
  };
  
  return (
    <div className={isPending ? 'opacity-50' : ''}>
      <form onSubmit={handleSubmit}>
        <input 
          type="search"
          value={query}
          onChange={(e) => setQuery(e.target.value)}
          placeholder="Search..."
        />
        <button type="submit">Search</button>
      </form>
      
      <div className="filters">
        <select 
          value={searchParams.get('sort') || 'relevance'}
          onChange={(e) => updateSearch({ sort: e.target.value })}
        >
          <option value="relevance">Relevance</option>
          <option value="date">Date</option>
          <option value="price">Price</option>
        </select>
        
        <select
          value={searchParams.get('category') || ''}
          onChange={(e) => updateSearch({ category: e.target.value })}
        >
          <option value="">All Categories</option>
          <option value="electronics">Electronics</option>
          <option value="clothing">Clothing</option>
        </select>
      </div>
      
      <div className="results">
        {results.map(item => (
          <div key={item.id}>{item.name}</div>
        ))}
      </div>
    </div>
  );
}
```

### Complex Example: Multi-Step Form

```tsx
// app/onboarding/layout.tsx
export default function OnboardingLayout({ children }) {
  return (
    <div className="onboarding">
      <header>
        <h1>Setup Your Account</h1>
      </header>
      <main>{children}</main>
    </div>
  );
}

// app/onboarding/page.tsx
import { redirect } from 'next/navigation';

export default function OnboardingStart() {
  redirect('/onboarding/step-1');
}

// app/onboarding/step-1/page.tsx
'use client';

import { useRouter } from 'next/navigation';
import { useState } from 'react';

export default function Step1() {
  const router = useRouter();
  const [name, setName] = useState('');
  
  const handleNext = () => {
    if (!name.trim()) return;
    
    // Store in localStorage or state management
    localStorage.setItem('onboarding_name', name);
    
    // Use replace so they can't go back to incomplete steps
    router.replace('/onboarding/step-2');
  };
  
  return (
    <div className="step">
      <h2>What's your name?</h2>
      <input 
        value={name}
        onChange={(e) => setName(e.target.value)}
        placeholder="Enter your name"
      />
      <button onClick={handleNext} disabled={!name.trim()}>
        Continue
      </button>
    </div>
  );
}

// app/onboarding/step-2/page.tsx
'use client';

import { useRouter } from 'next/navigation';
import { useState, useEffect } from 'react';

export default function Step2() {
  const router = useRouter();
  const [plan, setPlan] = useState('');
  
  // Ensure step 1 was completed
  useEffect(() => {
    const name = localStorage.getItem('onboarding_name');
    if (!name) {
      router.replace('/onboarding/step-1');
    }
  }, [router]);
  
  const handleNext = () => {
    if (!plan) return;
    localStorage.setItem('onboarding_plan', plan);
    router.replace('/onboarding/complete');
  };
  
  return (
    <div className="step">
      <h2>Choose your plan</h2>
      <div className="plans">
        {['free', 'pro', 'enterprise'].map(p => (
          <button 
            key={p}
            className={plan === p ? 'selected' : ''}
            onClick={() => setPlan(p)}
          >
            {p.charAt(0).toUpperCase() + p.slice(1)}
          </button>
        ))}
      </div>
      <button onClick={handleNext} disabled={!plan}>
        Continue
      </button>
    </div>
  );
}
```

### Edge Case Example: Handling Navigation States

```tsx
// components/NavigationGuard.tsx
'use client';

import { useEffect, useState } from 'react';
import { usePathname, useSearchParams } from 'next/navigation';

export function NavigationGuard({ 
  when, 
  message = 'You have unsaved changes. Are you sure you want to leave?' 
}) {
  const pathname = usePathname();
  const searchParams = useSearchParams();
  const [lastPath, setLastPath] = useState(pathname);
  
  useEffect(() => {
    // Browser navigation (refresh, close tab)
    const handleBeforeUnload = (e) => {
      if (when) {
        e.preventDefault();
        e.returnValue = message;
        return message;
      }
    };
    
    window.addEventListener('beforeunload', handleBeforeUnload);
    return () => window.removeEventListener('beforeunload', handleBeforeUnload);
  }, [when, message]);
  
  useEffect(() => {
    // Detect route change
    const fullPath = `${pathname}?${searchParams}`;
    if (fullPath !== lastPath && when) {
      const confirmed = window.confirm(message);
      if (!confirmed) {
        // Try to restore previous URL (limited in App Router)
        window.history.pushState(null, '', lastPath);
      } else {
        setLastPath(fullPath);
      }
    } else {
      setLastPath(fullPath);
    }
  }, [pathname, searchParams, when, message, lastPath]);
  
  return null;
}

// Usage
function EditForm() {
  const [hasChanges, setHasChanges] = useState(false);
  
  return (
    <>
      <NavigationGuard when={hasChanges} />
      <form onChange={() => setHasChanges(true)}>
        {/* form fields */}
      </form>
    </>
  );
}
```

## Key Takeaways

- Use `Link` for declarative navigation with automatic prefetching
- Use `useRouter` for programmatic navigation in Client Components
- Use `redirect` for server-side redirects in Server Components
- `router.push` adds to history; `router.replace` replaces current entry
- Reading URL: `usePathname` for path, `useSearchParams` for query params
- Navigation scrolls to top by default; disable with `scroll={false}`

## Questions & Answers

### Q: When should I use Link vs useRouter?
**A:** Use `Link` when you have a visible clickable element. Use `useRouter` for navigation triggered by logic (after form submit, based on conditions).

### Q: Why does useRouter only work in Client Components?
**A:** `useRouter` uses React hooks and browser APIs. Server Components can't access these. Use `redirect` on the server.

### Q: How do I prevent navigation if a form has unsaved changes?
**A:** There's no built-in solution in App Router. Use `beforeunload` for browser navigation and check state before programmatic navigation.

### Q: Can I listen to route changes?
**A:** Watch `usePathname` and `useSearchParams` in a `useEffect` to detect changes.

### Q: Why is my prefetch not working?
**A:** Prefetch only works in production. In development, it's disabled. Also check if `prefetch={false}` is set.

### Q: How do I navigate with state?
**A:** URL query params are the recommended way. For sensitive data, use cookies, sessionStorage, or state management.

## Resources

- [Next.js: Link Component](https://nextjs.org/docs/app/api-reference/components/link)
- [Next.js: useRouter](https://nextjs.org/docs/app/api-reference/functions/use-router)
- [Next.js: redirect](https://nextjs.org/docs/app/api-reference/functions/redirect)
- [Next.js: usePathname](https://nextjs.org/docs/app/api-reference/functions/use-pathname)
- [Next.js: useSearchParams](https://nextjs.org/docs/app/api-reference/functions/use-search-params)

