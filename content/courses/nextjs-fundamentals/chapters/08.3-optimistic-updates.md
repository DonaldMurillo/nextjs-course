# Chapter 8.3: Optimistic Updates

## Overview

Optimistic updates make your UI feel instant by updating the UI before the server confirms the change. If the server request fails, the UI reverts to the previous state. React's `useOptimistic` hook makes this pattern easy to implement.

## What Are Optimistic Updates?

Traditional approach:
```
User clicks ‚Üí Wait for server ‚Üí Update UI
             (user sees loading)
```

Optimistic approach:
```
User clicks ‚Üí Update UI immediately ‚Üí Wait for server
              (user sees result)      (revert if fails)
```

## useOptimistic Hook

```tsx
const [optimisticState, addOptimistic] = useOptimistic(
  currentState,
  (state, newValue) => {
    // Return the optimistically updated state
    return [...state, newValue];
  }
);
```

### Basic Usage

```tsx
// components/TodoList.tsx
"use client";

import { useOptimistic } from 'react';
import { addTodo } from '@/app/actions';

export function TodoList({ todos }) {
  const [optimisticTodos, addOptimisticTodo] = useOptimistic(
    todos,
    (state, newTodo) => [...state, { ...newTodo, pending: true }]
  );
  
  async function handleSubmit(formData) {
    const text = formData.get('text');
    
    // Optimistically add the todo
    addOptimisticTodo({ id: Date.now(), text, completed: false });
    
    // Actually create it on server
    await addTodo(formData);
  }
  
  return (
    <div>
      <form action={handleSubmit}>
        <input name="text" required />
        <button>Add</button>
      </form>
      
      <ul>
        {optimisticTodos.map(todo => (
          <li 
            key={todo.id}
            style={{ opacity: todo.pending ? 0.5 : 1 }}
          >
            {todo.text}
          </li>
        ))}
      </ul>
    </div>
  );
}
```

## Patterns

### Adding Items

```tsx
"use client";

import { useOptimistic } from 'react';
import { createComment } from '@/app/actions';

export function Comments({ comments }) {
  const [optimisticComments, addOptimisticComment] = useOptimistic(
    comments,
    (state, newComment) => [
      ...state,
      { ...newComment, id: `temp-${Date.now()}`, pending: true }
    ]
  );
  
  async function handleSubmit(formData) {
    const text = formData.get('text');
    const author = formData.get('author');
    
    addOptimisticComment({ text, author });
    await createComment(formData);
  }
  
  return (
    <div>
      {optimisticComments.map(comment => (
        <div 
          key={comment.id} 
          className={comment.pending ? 'pending' : ''}
        >
          <strong>{comment.author}</strong>
          <p>{comment.text}</p>
          {comment.pending && <span className="sending">Sending...</span>}
        </div>
      ))}
      
      <form action={handleSubmit}>
        <input name="author" placeholder="Name" required />
        <textarea name="text" placeholder="Comment" required />
        <button>Post Comment</button>
      </form>
    </div>
  );
}
```

### Removing Items

```tsx
"use client";

import { useOptimistic } from 'react';
import { deleteItem } from '@/app/actions';

export function ItemList({ items }) {
  const [optimisticItems, removeOptimisticItem] = useOptimistic(
    items,
    (state, deletedId) => state.filter(item => item.id !== deletedId)
  );
  
  async function handleDelete(id) {
    removeOptimisticItem(id);
    await deleteItem(id);
  }
  
  return (
    <ul>
      {optimisticItems.map(item => (
        <li key={item.id}>
          {item.name}
          <button onClick={() => handleDelete(item.id)}>Delete</button>
        </li>
      ))}
    </ul>
  );
}
```

### Toggling State

```tsx
"use client";

import { useOptimistic } from 'react';
import { toggleLike } from '@/app/actions';

export function LikeButton({ postId, isLiked, likeCount }) {
  const [optimisticLike, setOptimisticLike] = useOptimistic(
    { isLiked, likeCount },
    (state, newIsLiked) => ({
      isLiked: newIsLiked,
      likeCount: newIsLiked ? state.likeCount + 1 : state.likeCount - 1,
    })
  );
  
  async function handleClick() {
    setOptimisticLike(!optimisticLike.isLiked);
    await toggleLike(postId);
  }
  
  return (
    <button onClick={handleClick}>
      {optimisticLike.isLiked ? '‚ù§Ô∏è' : 'ü§ç'} {optimisticLike.likeCount}
    </button>
  );
}
```

### Updating Items

```tsx
"use client";

import { useOptimistic } from 'react';
import { updateTask } from '@/app/actions';

export function TaskList({ tasks }) {
  const [optimisticTasks, updateOptimisticTask] = useOptimistic(
    tasks,
    (state, { id, updates }) => 
      state.map(task => 
        task.id === id 
          ? { ...task, ...updates, pending: true }
          : task
      )
  );
  
  async function handleToggle(task) {
    updateOptimisticTask({
      id: task.id,
      updates: { completed: !task.completed }
    });
    
    await updateTask(task.id, { completed: !task.completed });
  }
  
  return (
    <ul>
      {optimisticTasks.map(task => (
        <li 
          key={task.id}
          style={{ opacity: task.pending ? 0.5 : 1 }}
        >
          <input
            type="checkbox"
            checked={task.completed}
            onChange={() => handleToggle(task)}
          />
          {task.title}
        </li>
      ))}
    </ul>
  );
}
```

## Error Handling

When a server action fails, the optimistic state automatically reverts when the parent component re-renders with the unchanged server data.

### Manual Error Handling

```tsx
"use client";

import { useOptimistic, useState } from 'react';
import { addItem } from '@/app/actions';

export function ItemForm({ items }) {
  const [error, setError] = useState(null);
  const [optimisticItems, addOptimisticItem] = useOptimistic(
    items,
    (state, newItem) => [...state, { ...newItem, pending: true }]
  );
  
  async function handleSubmit(formData) {
    setError(null);
    const name = formData.get('name');
    
    addOptimisticItem({ id: Date.now(), name });
    
    const result = await addItem(formData);
    
    if (result.error) {
      setError(result.error);
      // The optimistic update will revert when the component
      // re-renders with the unchanged items prop
    }
  }
  
  return (
    <div>
      {error && <p className="error">{error}</p>}
      
      <form action={handleSubmit}>
        <input name="name" required />
        <button>Add</button>
      </form>
      
      <ul>
        {optimisticItems.map(item => (
          <li key={item.id}>{item.name}</li>
        ))}
      </ul>
    </div>
  );
}
```

## Examples

### Basic Example: Quick Reply

```tsx
// components/QuickReply.tsx
"use client";

import { useOptimistic, useRef } from 'react';
import { sendReply } from '@/app/actions';

export function QuickReply({ replies }) {
  const formRef = useRef(null);
  const [optimisticReplies, addOptimisticReply] = useOptimistic(
    replies,
    (state, newReply) => [...state, newReply]
  );
  
  async function handleSubmit(formData) {
    const text = formData.get('text');
    
    addOptimisticReply({
      id: `temp-${Date.now()}`,
      text,
      author: 'You',
      pending: true,
      createdAt: new Date().toISOString(),
    });
    
    formRef.current?.reset();
    await sendReply(formData);
  }
  
  return (
    <div className="replies">
      {optimisticReplies.map(reply => (
        <div 
          key={reply.id} 
          className={`reply ${reply.pending ? 'pending' : ''}`}
        >
          <strong>{reply.author}</strong>
          <p>{reply.text}</p>
          {reply.pending && <span className="indicator">Sending...</span>}
        </div>
      ))}
      
      <form ref={formRef} action={handleSubmit}>
        <input name="text" placeholder="Write a reply..." required />
        <button>Send</button>
      </form>
    </div>
  );
}
```

### Normal Example: Shopping Cart

```tsx
// components/Cart.tsx
"use client";

import { useOptimistic } from 'react';
import { updateQuantity, removeItem } from '@/app/actions';

export function Cart({ items }) {
  const [optimisticItems, updateOptimisticItems] = useOptimistic(
    items,
    (state, action) => {
      switch (action.type) {
        case 'UPDATE_QUANTITY':
          return state.map(item =>
            item.id === action.id
              ? { ...item, quantity: action.quantity, pending: true }
              : item
          );
        case 'REMOVE':
          return state.filter(item => item.id !== action.id);
        default:
          return state;
      }
    }
  );
  
  async function handleQuantityChange(id, newQuantity) {
    updateOptimisticItems({ type: 'UPDATE_QUANTITY', id, quantity: newQuantity });
    await updateQuantity(id, newQuantity);
  }
  
  async function handleRemove(id) {
    updateOptimisticItems({ type: 'REMOVE', id });
    await removeItem(id);
  }
  
  const total = optimisticItems.reduce(
    (sum, item) => sum + item.price * item.quantity,
    0
  );
  
  return (
    <div className="cart">
      {optimisticItems.map(item => (
        <div 
          key={item.id} 
          className={`cart-item ${item.pending ? 'pending' : ''}`}
        >
          <img src={item.image} alt={item.name} />
          <div className="details">
            <h3>{item.name}</h3>
            <p>${item.price}</p>
          </div>
          <select
            value={item.quantity}
            onChange={(e) => handleQuantityChange(item.id, parseInt(e.target.value))}
          >
            {[1, 2, 3, 4, 5].map(n => (
              <option key={n} value={n}>{n}</option>
            ))}
          </select>
          <button onClick={() => handleRemove(item.id)}>Remove</button>
        </div>
      ))}
      
      <div className="total">
        <strong>Total: ${total.toFixed(2)}</strong>
      </div>
    </div>
  );
}
```

### Complex Example: Kanban Board

```tsx
// components/KanbanBoard.tsx
"use client";

import { useOptimistic } from 'react';
import { moveTask, updateTaskStatus } from '@/app/actions';

export function KanbanBoard({ columns }) {
  const [optimisticColumns, updateOptimisticColumns] = useOptimistic(
    columns,
    (state, action) => {
      switch (action.type) {
        case 'MOVE_TASK': {
          const { taskId, fromColumn, toColumn } = action;
          return state.map(col => {
            if (col.id === fromColumn) {
              return {
                ...col,
                tasks: col.tasks.filter(t => t.id !== taskId),
              };
            }
            if (col.id === toColumn) {
              const task = columns
                .find(c => c.id === fromColumn)
                ?.tasks.find(t => t.id === taskId);
              return {
                ...col,
                tasks: [...col.tasks, { ...task, pending: true }],
              };
            }
            return col;
          });
        }
        default:
          return state;
      }
    }
  );
  
  async function handleDrop(taskId, fromColumn, toColumn) {
    if (fromColumn === toColumn) return;
    
    updateOptimisticColumns({
      type: 'MOVE_TASK',
      taskId,
      fromColumn,
      toColumn,
    });
    
    await moveTask(taskId, toColumn);
  }
  
  return (
    <div className="kanban-board">
      {optimisticColumns.map(column => (
        <div 
          key={column.id} 
          className="column"
          onDrop={(e) => {
            const taskId = e.dataTransfer.getData('taskId');
            const fromColumn = e.dataTransfer.getData('fromColumn');
            handleDrop(taskId, fromColumn, column.id);
          }}
          onDragOver={(e) => e.preventDefault()}
        >
          <h2>{column.title}</h2>
          {column.tasks.map(task => (
            <div
              key={task.id}
              className={`task ${task.pending ? 'pending' : ''}`}
              draggable
              onDragStart={(e) => {
                e.dataTransfer.setData('taskId', task.id);
                e.dataTransfer.setData('fromColumn', column.id);
              }}
            >
              {task.title}
            </div>
          ))}
        </div>
      ))}
    </div>
  );
}
```

### Edge Case Example: With Undo

```tsx
// components/MessageList.tsx
"use client";

import { useOptimistic, useState } from 'react';
import { deleteMessage } from '@/app/actions';

export function MessageList({ messages }) {
  const [undoQueue, setUndoQueue] = useState([]);
  const [optimisticMessages, updateOptimistic] = useOptimistic(
    messages,
    (state, action) => {
      switch (action.type) {
        case 'DELETE':
          return state.filter(m => m.id !== action.id);
        case 'RESTORE':
          return [...state, action.message];
        default:
          return state;
      }
    }
  );
  
  async function handleDelete(message) {
    // Show undo option for 5 seconds
    const undoItem = { message, timeoutId: null };
    
    updateOptimistic({ type: 'DELETE', id: message.id });
    
    setUndoQueue(prev => [...prev, undoItem]);
    
    undoItem.timeoutId = setTimeout(async () => {
      // Actually delete after undo window expires
      setUndoQueue(prev => prev.filter(u => u !== undoItem));
      await deleteMessage(message.id);
    }, 5000);
  }
  
  function handleUndo(undoItem) {
    clearTimeout(undoItem.timeoutId);
    setUndoQueue(prev => prev.filter(u => u !== undoItem));
    updateOptimistic({ type: 'RESTORE', message: undoItem.message });
  }
  
  return (
    <div>
      {undoQueue.length > 0 && (
        <div className="undo-bar">
          Message deleted.{' '}
          <button onClick={() => handleUndo(undoQueue[undoQueue.length - 1])}>
            Undo
          </button>
        </div>
      )}
      
      <ul>
        {optimisticMessages.map(message => (
          <li key={message.id}>
            {message.text}
            <button onClick={() => handleDelete(message)}>Delete</button>
          </li>
        ))}
      </ul>
    </div>
  );
}
```

## Best Practices

### 1. Show Pending State

```tsx
// ‚úÖ Good: Visual feedback for pending items
{optimisticItems.map(item => (
  <li 
    key={item.id}
    className={item.pending ? 'opacity-50' : ''}
  >
    {item.name}
    {item.pending && <span className="ml-2">Saving...</span>}
  </li>
))}
```

### 2. Use Temporary IDs

```tsx
// ‚úÖ Good: Temporary ID for new items
addOptimisticItem({
  id: `temp-${Date.now()}`,  // Temporary ID
  text: inputText,
  pending: true,
});
```

### 3. Clear Form on Submit

```tsx
const formRef = useRef(null);

async function handleSubmit(formData) {
  addOptimisticItem({ ... });
  formRef.current?.reset();  // Clear form immediately
  await action(formData);
}
```

## Key Takeaways

- `useOptimistic` provides instant UI feedback
- Updates revert automatically if the server action fails
- Use a `pending` flag to show visual feedback
- Clear forms immediately after optimistic update
- Combine with `useTransition` for additional pending states

## Questions & Answers

### Q: What happens if the server action fails?
**A:** When the component re-renders with unchanged props from the server, the optimistic state reverts automatically.

### Q: Can I use useOptimistic with useActionState?
**A:** Yes! They solve different problems. `useOptimistic` is for instant UI updates, `useActionState` is for form state management.

### Q: How do I show an error when an optimistic update fails?
**A:** Handle errors in your action and display them. The optimistic state will revert when the parent re-renders.

### Q: Does useOptimistic work with Server Components?
**A:** `useOptimistic` must be used in Client Components, but it works with data fetched by Server Components.

## Resources

- [React: useOptimistic](https://react.dev/reference/react/useOptimistic)
- [Next.js: Optimistic Updates](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations#optimistic-updates)

---

**Next Chapter:** [9. Styling in Next.js](./09-styling.md) - Learn how to style your Next.js applications with CSS Modules and Tailwind.
