# Chapter 6.3: Common Mistakes & Gotchas

## Overview

Server and Client Components have sharp edges. This chapter covers the most common mistakes developers make and how to avoid them. Save yourself hours of debugging by learning these patterns upfront.

## Mistake 1: Using Hooks in Server Components

Server Components cannot use React hooks because hooks require the React client runtime.

### The Error

```tsx
// app/page.tsx (Server Component - no "use client")
import { useState } from 'react';

export default function Page() {
  const [count, setCount] = useState(0);  // ❌ Error!
  
  return <button onClick={() => setCount(count + 1)}>{count}</button>;
}
```

Error: `useState` only works in Client Components. Add the `"use client"` directive.

### The Fix

Either add `"use client"` or extract the stateful logic:

```tsx
// Option 1: Make it a Client Component
"use client";

import { useState } from 'react';

export default function Page() {
  const [count, setCount] = useState(0);
  return <button onClick={() => setCount(count + 1)}>{count}</button>;
}

// Option 2: Extract the interactive part
// app/page.tsx (Server)
import { Counter } from '@/components/Counter';

export default function Page() {
  return (
    <div>
      <h1>My Page</h1>
      <Counter />
    </div>
  );
}

// components/Counter.tsx (Client)
"use client";

import { useState } from 'react';

export function Counter() {
  const [count, setCount] = useState(0);
  return <button onClick={() => setCount(count + 1)}>{count}</button>;
}
```

## Mistake 2: Passing Functions as Props

Functions can't be serialized and sent from server to client.

### The Error

```tsx
// app/page.tsx (Server Component)
export default function Page() {
  const handleClick = () => {
    console.log('clicked');
  };
  
  return <ClientButton onClick={handleClick} />;  // ❌ Error!
}
```

Error: Functions cannot be passed as props from Server to Client Components.

### The Fix

Use Server Actions or move the logic to the Client Component:

```tsx
// Option 1: Server Actions (for data mutations)
// app/actions.ts
"use server";

export async function handleSubmit(formData) {
  // Server-side logic
  await saveData(formData);
}

// app/page.tsx
import { handleSubmit } from './actions';

export default function Page() {
  return (
    <form action={handleSubmit}>
      <input name="email" />
      <button type="submit">Submit</button>
    </form>
  );
}

// Option 2: Move logic to Client Component
// components/ClientButton.tsx
"use client";

export function ClientButton() {
  const handleClick = () => {
    console.log('clicked');
  };
  
  return <button onClick={handleClick}>Click me</button>;
}
```

## Mistake 3: Importing Server Components in Client Components

Client Components cannot import Server Components directly.

### The Error

```tsx
// components/ClientWrapper.tsx
"use client";

import { ServerData } from './ServerData';  // ❌ This won't work as expected

export function ClientWrapper() {
  return <ServerData />;  // ServerData becomes a Client Component!
}
```

The import doesn't error, but `ServerData` is now treated as a Client Component—it runs in the browser, not the server.

### The Fix

Use the children pattern:

```tsx
// app/page.tsx (Server Component)
import { ClientWrapper } from '@/components/ClientWrapper';
import { ServerData } from '@/components/ServerData';

export default function Page() {
  return (
    <ClientWrapper>
      <ServerData />  {/* ✅ Rendered on server, passed as children */}
    </ClientWrapper>
  );
}

// components/ClientWrapper.tsx
"use client";

export function ClientWrapper({ children }) {
  return <div className="wrapper">{children}</div>;
}

// components/ServerData.tsx (Server - no "use client")
export async function ServerData() {
  const data = await fetchData();
  return <div>{data.content}</div>;
}
```

## Mistake 4: Accessing Browser APIs in Server Components

Server Components run in Node.js, which doesn't have browser APIs.

### The Error

```tsx
// app/page.tsx (Server Component)
export default function Page() {
  const width = window.innerWidth;  // ❌ Error! window is undefined
  const theme = localStorage.getItem('theme');  // ❌ Error!
  
  return <div>Width: {width}</div>;
}
```

### The Fix

Use Client Components for browser APIs:

```tsx
// components/WindowSize.tsx
"use client";

import { useState, useEffect } from 'react';

export function WindowSize() {
  const [width, setWidth] = useState(null);
  
  useEffect(() => {
    setWidth(window.innerWidth);
    
    const handleResize = () => setWidth(window.innerWidth);
    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, []);
  
  if (width === null) return null;  // Prevent hydration mismatch
  
  return <div>Width: {width}</div>;
}
```

## Mistake 5: Hydration Mismatches

When server and client render different content, React complains.

### The Error

```tsx
// components/Timestamp.tsx
"use client";

export function Timestamp() {
  return <span>{new Date().toLocaleString()}</span>;
  // ❌ Server and client will render different times!
}
```

Warning: Text content did not match. Server: "11/15/2024, 10:00:00 AM" Client: "11/15/2024, 10:00:01 AM"

### The Fix

Use `useEffect` for client-only values:

```tsx
// components/Timestamp.tsx
"use client";

import { useState, useEffect } from 'react';

export function Timestamp() {
  const [time, setTime] = useState(null);
  
  useEffect(() => {
    setTime(new Date().toLocaleString());
  }, []);
  
  if (time === null) {
    return <span>Loading...</span>;  // Same on server and client
  }
  
  return <span>{time}</span>;
}
```

Or suppress hydration warnings when intentional:

```tsx
export function Timestamp() {
  return (
    <span suppressHydrationWarning>
      {new Date().toLocaleString()}
    </span>
  );
}
```

## Mistake 6: Passing Non-Serializable Data

Objects with special types can't cross the server-client boundary.

### The Error

```tsx
// app/page.tsx (Server Component)
export default async function Page() {
  const event = await getEvent();
  
  return (
    <EventCard 
      event={event}  // ❌ event.date might be a Date object
    />
  );
}
```

### The Fix

Convert to serializable formats:

```tsx
// app/page.tsx (Server Component)
export default async function Page() {
  const event = await getEvent();
  
  // Convert non-serializable data
  const serializedEvent = {
    ...event,
    date: event.date.toISOString(),  // Date → string
    metadata: JSON.stringify(event.metadata),  // Complex object → string
  };
  
  return <EventCard event={serializedEvent} />;
}

// components/EventCard.tsx (Client)
"use client";

export function EventCard({ event }) {
  // Reconstruct if needed
  const date = new Date(event.date);
  
  return (
    <div>
      <h2>{event.title}</h2>
      <p>{date.toLocaleDateString()}</p>
    </div>
  );
}
```

## Mistake 7: Forgetting "use client"

Missing the directive causes confusing errors when using hooks.

### The Error

```tsx
// components/Toggle.tsx
// Forgot "use client"!

import { useState } from 'react';

export function Toggle() {
  const [on, setOn] = useState(false);  // Error here
  
  return <button onClick={() => setOn(!on)}>{on ? 'ON' : 'OFF'}</button>;
}
```

### The Fix

Add `"use client"` at the very top:

```tsx
// components/Toggle.tsx
"use client";  // Must be first line (before imports)

import { useState } from 'react';

export function Toggle() {
  const [on, setOn] = useState(false);
  return <button onClick={() => setOn(!on)}>{on ? 'ON' : 'OFF'}</button>;
}
```

## Mistake 8: Over-Client-ifying

Making everything a Client Component defeats the purpose.

### The Problem

```tsx
// ❌ Don't do this
"use client";

export default function ProductPage() {
  const [products, setProducts] = useState([]);
  
  useEffect(() => {
    fetch('/api/products')
      .then(res => res.json())
      .then(setProducts);
  }, []);
  
  return (
    <div>
      {products.map(p => (
        <div key={p.id}>
          <h3>{p.name}</h3>
          <p>{p.description}</p>
          {/* 50 more lines of static content */}
        </div>
      ))}
    </div>
  );
}
```

### The Fix

Fetch on the server, make only interactive parts client-side:

```tsx
// app/products/page.tsx (Server)
export default async function ProductPage() {
  const products = await getProducts();  // Server-side fetch
  
  return (
    <div>
      {products.map(p => (
        <ProductCard key={p.id} product={p} />
      ))}
    </div>
  );
}

// components/ProductCard.tsx (Server)
import { AddToCartButton } from './AddToCartButton';

export function ProductCard({ product }) {
  return (
    <div>
      <h3>{product.name}</h3>
      <p>{product.description}</p>
      {/* Static content stays on server */}
      <AddToCartButton productId={product.id} />  {/* Only this is client */}
    </div>
  );
}

// components/AddToCartButton.tsx (Client)
"use client";

export function AddToCartButton({ productId }) {
  return <button onClick={() => addToCart(productId)}>Add to Cart</button>;
}
```

## Mistake 9: Async Client Components

Client Components cannot be async.

### The Error

```tsx
// components/DataLoader.tsx
"use client";

// ❌ Client Components can't be async!
export async function DataLoader() {
  const data = await fetch('/api/data');
  return <div>{data}</div>;
}
```

### The Fix

Use `useEffect` for client-side fetching, or make it a Server Component:

```tsx
// Option 1: useEffect (Client Component)
"use client";

import { useState, useEffect } from 'react';

export function DataLoader() {
  const [data, setData] = useState(null);
  
  useEffect(() => {
    fetch('/api/data')
      .then(res => res.json())
      .then(setData);
  }, []);
  
  if (!data) return <div>Loading...</div>;
  return <div>{data.content}</div>;
}

// Option 2: Server Component (remove "use client")
export async function DataLoader() {
  const data = await fetch('https://api.example.com/data');
  return <div>{data.content}</div>;
}
```

## Mistake 10: Environment Variable Exposure

Forgetting that Server Components can safely use secrets, but Client Components cannot.

### The Problem

```tsx
// components/ApiClient.tsx
"use client";

export function ApiClient() {
  // ❌ API key exposed to browser!
  const apiKey = process.env.API_KEY;
  
  const fetchData = async () => {
    const res = await fetch(`/api?key=${apiKey}`);
  };
}
```

### The Fix

Use `NEXT_PUBLIC_` prefix only for public values, keep secrets server-side:

```tsx
// Server Component - secrets are safe
export async function DataFetcher() {
  const apiKey = process.env.API_KEY;  // ✅ Safe, server-only
  const data = await fetch(`https://api.example.com?key=${apiKey}`);
  return <ClientDisplay data={data} />;
}

// Or use a Server Action
"use server";

export async function fetchSecureData() {
  const apiKey = process.env.API_KEY;  // ✅ Safe
  const data = await fetch(`https://api.example.com?key=${apiKey}`);
  return data;
}

// Client Component
"use client";

export function DataClient() {
  const publicApiUrl = process.env.NEXT_PUBLIC_API_URL;  // ✅ Only public values
}
```

## Quick Reference: What Works Where

| Feature | Server Component | Client Component |
|---------|-----------------|------------------|
| `async/await` in component | ✅ | ❌ |
| `useState` | ❌ | ✅ |
| `useEffect` | ❌ | ✅ |
| `onClick`, `onChange` | ❌ | ✅ |
| `window`, `document` | ❌ | ✅ |
| Direct database access | ✅ | ❌ |
| Access secrets/env vars | ✅ | ⚠️ NEXT_PUBLIC_ only |
| Render Client Components | ✅ | ✅ |
| Import Server Components | ✅ | ❌ (use children) |

## Examples

### Basic Example: Fixing Hook Error

```tsx
// ❌ Before: Error
// app/page.tsx
import { useState } from 'react';

export default function Page() {
  const [name, setName] = useState('');
  return <input value={name} onChange={e => setName(e.target.value)} />;
}

// ✅ After: Fixed
// app/page.tsx
import { NameInput } from '@/components/NameInput';

export default function Page() {
  return <NameInput />;
}

// components/NameInput.tsx
"use client";

import { useState } from 'react';

export function NameInput() {
  const [name, setName] = useState('');
  return <input value={name} onChange={e => setName(e.target.value)} />;
}
```

### Normal Example: Fixing Serialization Error

```tsx
// ❌ Before: Serialization error
// app/users/page.tsx
export default async function UsersPage() {
  const users = await db.users.findMany({
    include: { posts: true }
  });
  
  return <UserList users={users} />;  // Prisma objects may not serialize cleanly
}

// ✅ After: Fixed
// app/users/page.tsx
export default async function UsersPage() {
  const users = await db.users.findMany({
    include: { posts: true }
  });
  
  // Convert to plain objects
  const serializedUsers = users.map(user => ({
    id: user.id,
    name: user.name,
    email: user.email,
    createdAt: user.createdAt.toISOString(),
    posts: user.posts.map(post => ({
      id: post.id,
      title: post.title,
    })),
  }));
  
  return <UserList users={serializedUsers} />;
}
```

### Complex Example: Refactoring Client-Heavy Page

```tsx
// ❌ Before: Everything is client-side
"use client";

import { useState, useEffect } from 'react';

export default function DashboardPage() {
  const [user, setUser] = useState(null);
  const [stats, setStats] = useState(null);
  const [recentActivity, setRecentActivity] = useState([]);
  
  useEffect(() => {
    Promise.all([
      fetch('/api/user').then(r => r.json()),
      fetch('/api/stats').then(r => r.json()),
      fetch('/api/activity').then(r => r.json()),
    ]).then(([userData, statsData, activityData]) => {
      setUser(userData);
      setStats(statsData);
      setRecentActivity(activityData);
    });
  }, []);
  
  if (!user || !stats) return <div>Loading...</div>;
  
  return (
    <div>
      <h1>Welcome, {user.name}</h1>
      <div className="stats">
        <div>Revenue: ${stats.revenue}</div>
        <div>Orders: {stats.orders}</div>
      </div>
      <div className="activity">
        {recentActivity.map(item => (
          <div key={item.id}>{item.description}</div>
        ))}
      </div>
      <button onClick={() => setStats(null)}>Refresh</button>
    </div>
  );
}

// ✅ After: Mostly server, small client parts
// app/dashboard/page.tsx (Server)
import { getUser, getStats, getActivity } from '@/lib/data';
import { RefreshButton } from '@/components/RefreshButton';

export default async function DashboardPage() {
  const [user, stats, recentActivity] = await Promise.all([
    getUser(),
    getStats(),
    getActivity(),
  ]);
  
  return (
    <div>
      <h1>Welcome, {user.name}</h1>
      <div className="stats">
        <div>Revenue: ${stats.revenue}</div>
        <div>Orders: {stats.orders}</div>
      </div>
      <div className="activity">
        {recentActivity.map(item => (
          <div key={item.id}>{item.description}</div>
        ))}
      </div>
      <RefreshButton />
    </div>
  );
}

// components/RefreshButton.tsx (Client)
"use client";

import { useRouter } from 'next/navigation';

export function RefreshButton() {
  const router = useRouter();
  
  return (
    <button onClick={() => router.refresh()}>
      Refresh
    </button>
  );
}
```

## Key Takeaways

- Server Components can't use hooks or browser APIs
- Client Components can't be async or import Server Components directly
- Functions can't be passed from Server to Client (use Server Actions)
- Data crossing the boundary must be serializable
- Hydration mismatches occur when server/client render differently
- Keep secrets in Server Components only
- Don't over-use Client Components—default to Server

## Questions & Answers

### Q: How do I debug whether something is a Server or Client Component?
**A:** Add a `console.log` at the top of the component. Server logs appear in your terminal; client logs appear in browser DevTools.

### Q: Why is my Client Component fetching data on every render?
**A:** You might be missing a dependency array in `useEffect`, or the component is re-mounting. Consider fetching in a Server Component instead.

### Q: Can I use a library that requires `window` in a Server Component?
**A:** No. Create a Client Component wrapper for that library.

### Q: How do I know if a third-party component needs "use client"?
**A:** If it uses hooks, event handlers, or browser APIs, it needs to be in a Client Component. Check the library documentation or error messages.

## Resources

- [Next.js: Server Component Patterns](https://nextjs.org/docs/app/building-your-application/rendering/composition-patterns)
- [React: Rules of Server Components](https://react.dev/reference/rsc/server-components#rules)
- [Vercel: Common Mistakes with Server Components](https://vercel.com/blog/common-mistakes-with-the-next-js-app-router-and-how-to-fix-them)

---

**Next Chapter:** [7. Data Fetching](./07-data-fetching.md) - Learn how to fetch, cache, and revalidate data in Next.js.
