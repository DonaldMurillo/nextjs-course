# Chapter 7.1: Fetching in Server Components

## Overview

Server Components can fetch data directly during rendering. No API routes, no useEffect, no loading state boilerplate. This chapter covers how to fetch data effectively in Server Components.

## Basic Fetching

### Using fetch

```tsx
// app/products/page.tsx
async function getProducts() {
  const res = await fetch('https://api.example.com/products');
  
  if (!res.ok) {
    throw new Error('Failed to fetch products');
  }
  
  return res.json();
}

export default async function ProductsPage() {
  const products = await getProducts();
  
  return (
    <ul>
      {products.map(product => (
        <li key={product.id}>{product.name}</li>
      ))}
    </ul>
  );
}
```

### Direct Database Queries

With Prisma:

```tsx
// app/users/page.tsx
import { prisma } from '@/lib/prisma';

export default async function UsersPage() {
  const users = await prisma.user.findMany({
    select: {
      id: true,
      name: true,
      email: true,
    },
  });
  
  return (
    <ul>
      {users.map(user => (
        <li key={user.id}>{user.name}</li>
      ))}
    </ul>
  );
}
```

With raw SQL:

```tsx
// app/stats/page.tsx
import { sql } from '@/lib/db';

export default async function StatsPage() {
  const stats = await sql`
    SELECT 
      COUNT(*) as total_users,
      COUNT(CASE WHEN created_at > NOW() - INTERVAL '24 hours' THEN 1 END) as new_users
    FROM users
  `;
  
  return (
    <div>
      <p>Total Users: {stats[0].total_users}</p>
      <p>New Users (24h): {stats[0].new_users}</p>
    </div>
  );
}
```

## Sequential vs Parallel Fetching

### Sequential (Waterfall)

Each request waits for the previous one:

```tsx
// ❌ Slow: Sequential fetching
async function Dashboard() {
  const user = await getUser();           // Wait...
  const posts = await getPosts();          // Then wait...
  const comments = await getComments();    // Then wait...
  
  // Total time: user + posts + comments
  return <DashboardView user={user} posts={posts} comments={comments} />;
}
```

### Parallel (Recommended)

Fetch all data simultaneously:

```tsx
// ✅ Fast: Parallel fetching
async function Dashboard() {
  const [user, posts, comments] = await Promise.all([
    getUser(),
    getPosts(),
    getComments(),
  ]);
  
  // Total time: max(user, posts, comments)
  return <DashboardView user={user} posts={posts} comments={comments} />;
}
```

### When Sequential Makes Sense

When one request depends on another:

```tsx
async function UserPosts({ userId }) {
  // Must get user first to know their preferences
  const user = await getUser(userId);
  
  // Posts query depends on user's settings
  const posts = await getPosts({
    authorId: userId,
    limit: user.postsPerPage,
  });
  
  return <PostList posts={posts} />;
}
```

## Request Deduplication

Next.js automatically deduplicates identical `fetch` requests within a single render pass:

```tsx
// app/layout.tsx
async function Layout({ children }) {
  const user = await fetch('https://api.example.com/user').then(r => r.json());
  return <div><Header user={user} />{children}</div>;
}

// app/page.tsx
async function Page() {
  // Same request - Next.js deduplicates it!
  const user = await fetch('https://api.example.com/user').then(r => r.json());
  return <Profile user={user} />;
}
```

Only one network request is made, even though `fetch` is called twice.

### Deduplication Rules

- Same URL
- Same fetch options
- Within the same render pass
- Only works with `fetch`, not database queries

### Manual Deduplication with React Cache

For non-fetch data sources, use React's `cache`:

```tsx
// lib/data.ts
import { cache } from 'react';
import { prisma } from './prisma';

export const getUser = cache(async (userId) => {
  return prisma.user.findUnique({
    where: { id: userId },
  });
});

// Now multiple components can call getUser(123)
// and only one database query runs
```

## Fetching with Dynamic Parameters

### Route Parameters

```tsx
// app/products/[id]/page.tsx
async function getProduct(id) {
  const res = await fetch(`https://api.example.com/products/${id}`);
  if (!res.ok) return null;
  return res.json();
}

export default async function ProductPage({ params }) {
  const { id } = await params;
  const product = await getProduct(id);
  
  if (!product) {
    notFound();
  }
  
  return <ProductDetails product={product} />;
}
```

### Search Parameters

```tsx
// app/search/page.tsx
async function searchProducts(query, page = 1) {
  const res = await fetch(
    `https://api.example.com/search?q=${encodeURIComponent(query)}&page=${page}`
  );
  return res.json();
}

export default async function SearchPage({ searchParams }) {
  const { q = '', page = '1' } = await searchParams;
  const results = await searchProducts(q, parseInt(page));
  
  return (
    <div>
      <h1>Results for "{q}"</h1>
      <ProductGrid products={results.products} />
      <Pagination total={results.total} current={parseInt(page)} />
    </div>
  );
}
```

## Error Handling

### Throwing Errors

Errors thrown in Server Components are caught by the nearest `error.js`:

```tsx
// app/products/page.tsx
async function getProducts() {
  const res = await fetch('https://api.example.com/products');
  
  if (!res.ok) {
    throw new Error(`Failed to fetch: ${res.status}`);
  }
  
  return res.json();
}

export default async function ProductsPage() {
  const products = await getProducts();  // Error will bubble up
  return <ProductList products={products} />;
}

// app/products/error.tsx
'use client';

export default function ProductsError({ error, reset }) {
  return (
    <div>
      <h2>Failed to load products</h2>
      <p>{error.message}</p>
      <button onClick={reset}>Try again</button>
    </div>
  );
}
```

### Handling Expected Errors

For expected failures (like 404), handle them gracefully:

```tsx
// app/blog/[slug]/page.tsx
import { notFound } from 'next/navigation';

async function getPost(slug) {
  const res = await fetch(`https://api.example.com/posts/${slug}`);
  
  if (res.status === 404) {
    return null;  // Expected: post doesn't exist
  }
  
  if (!res.ok) {
    throw new Error('Failed to fetch post');  // Unexpected error
  }
  
  return res.json();
}

export default async function BlogPost({ params }) {
  const { slug } = await params;
  const post = await getPost(slug);
  
  if (!post) {
    notFound();  // Renders not-found.js
  }
  
  return <Article post={post} />;
}
```

## Examples

### Basic Example: Simple Data Fetch

```tsx
// app/quote/page.tsx
async function getQuote() {
  const res = await fetch('https://api.quotable.io/random');
  return res.json();
}

export default async function QuotePage() {
  const quote = await getQuote();
  
  return (
    <blockquote>
      <p>"{quote.content}"</p>
      <footer>— {quote.author}</footer>
    </blockquote>
  );
}
```

### Normal Example: List with Filtering

```tsx
// app/products/page.tsx
async function getProducts(category, sort) {
  const params = new URLSearchParams();
  if (category) params.set('category', category);
  if (sort) params.set('sort', sort);
  
  const res = await fetch(`https://api.example.com/products?${params}`);
  return res.json();
}

async function getCategories() {
  const res = await fetch('https://api.example.com/categories');
  return res.json();
}

export default async function ProductsPage({ searchParams }) {
  const { category, sort } = await searchParams;
  
  const [products, categories] = await Promise.all([
    getProducts(category, sort),
    getCategories(),
  ]);
  
  return (
    <div>
      <FilterBar categories={categories} current={category} />
      <SortSelector current={sort} />
      <ProductGrid products={products} />
    </div>
  );
}
```

### Complex Example: Dashboard with Multiple Data Sources

```tsx
// app/dashboard/page.tsx
import { prisma } from '@/lib/prisma';
import { cache } from 'react';

// Cached database queries
const getUser = cache(async (userId) => {
  return prisma.user.findUnique({
    where: { id: userId },
    select: { id: true, name: true, email: true, role: true },
  });
});

const getStats = cache(async (userId) => {
  const [orders, revenue, customers] = await Promise.all([
    prisma.order.count({ where: { userId } }),
    prisma.order.aggregate({
      where: { userId },
      _sum: { total: true },
    }),
    prisma.customer.count({ where: { userId } }),
  ]);
  
  return {
    orders,
    revenue: revenue._sum.total || 0,
    customers,
  };
});

// External API
async function getNotifications(userId) {
  const res = await fetch(`https://api.example.com/notifications/${userId}`, {
    next: { revalidate: 60 },  // Cache for 1 minute
  });
  return res.json();
}

// Analytics (different service)
async function getAnalytics(userId) {
  const res = await fetch(`https://analytics.example.com/user/${userId}`, {
    headers: {
      'Authorization': `Bearer ${process.env.ANALYTICS_API_KEY}`,
    },
  });
  return res.json();
}

export default async function DashboardPage() {
  // Get user ID from session (simplified)
  const userId = await getCurrentUserId();
  
  // Parallel fetch from multiple sources
  const [user, stats, notifications, analytics] = await Promise.all([
    getUser(userId),
    getStats(userId),
    getNotifications(userId),
    getAnalytics(userId),
  ]);
  
  return (
    <div className="dashboard">
      <header>
        <h1>Welcome, {user.name}</h1>
        <NotificationBell count={notifications.unread} />
      </header>
      
      <section className="stats">
        <StatCard title="Orders" value={stats.orders} />
        <StatCard title="Revenue" value={`$${stats.revenue}`} />
        <StatCard title="Customers" value={stats.customers} />
      </section>
      
      <section className="analytics">
        <AnalyticsChart data={analytics.chartData} />
      </section>
      
      <section className="activity">
        <RecentActivity items={analytics.recentEvents} />
      </section>
    </div>
  );
}
```

### Edge Case Example: Handling Timeouts and Retries

```tsx
// lib/fetch-with-retry.ts
export async function fetchWithRetry(url, options = {}, retries = 3) {
  const { timeout = 5000, ...fetchOptions } = options;
  
  for (let attempt = 1; attempt <= retries; attempt++) {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), timeout);
    
    try {
      const res = await fetch(url, {
        ...fetchOptions,
        signal: controller.signal,
      });
      
      clearTimeout(timeoutId);
      
      if (!res.ok) {
        throw new Error(`HTTP ${res.status}`);
      }
      
      return res;
    } catch (error) {
      clearTimeout(timeoutId);
      
      const isLastAttempt = attempt === retries;
      const isRetryable = 
        error.name === 'AbortError' ||  // Timeout
        error.message.includes('5');     // 5xx errors
      
      if (isLastAttempt || !isRetryable) {
        throw error;
      }
      
      // Exponential backoff
      await new Promise(resolve => 
        setTimeout(resolve, Math.pow(2, attempt) * 100)
      );
    }
  }
}

// app/data/page.tsx
import { fetchWithRetry } from '@/lib/fetch-with-retry';

export default async function DataPage() {
  try {
    const res = await fetchWithRetry(
      'https://api.example.com/data',
      { timeout: 3000 },
      3
    );
    const data = await res.json();
    return <DataDisplay data={data} />;
  } catch (error) {
    // After all retries failed
    return <ErrorMessage error={error} />;
  }
}
```

## Best Practices

### 1. Use Parallel Fetching

```tsx
// ✅ Good
const [a, b, c] = await Promise.all([fetchA(), fetchB(), fetchC()]);

// ❌ Avoid
const a = await fetchA();
const b = await fetchB();
const c = await fetchC();
```

### 2. Create Data Fetching Functions

```tsx
// ✅ Good: Reusable, testable
// lib/data.ts
export async function getProducts() {
  const res = await fetch('https://api.example.com/products');
  return res.json();
}

// app/page.tsx
import { getProducts } from '@/lib/data';

// ❌ Avoid: Inline fetching
export default async function Page() {
  const res = await fetch('https://api.example.com/products');
  const products = await res.json();
}
```

### 3. Handle Errors Appropriately

```tsx
// ✅ Good: Distinguish between error types
async function getData(id) {
  const res = await fetch(`/api/data/${id}`);
  
  if (res.status === 404) return null;  // Expected
  if (!res.ok) throw new Error(`Fetch failed: ${res.status}`);  // Unexpected
  
  return res.json();
}
```

### 4. Use React Cache for Non-Fetch Data

```tsx
// ✅ Good: Deduplicated database queries
import { cache } from 'react';

export const getUser = cache(async (id) => {
  return db.user.findUnique({ where: { id } });
});
```

## Key Takeaways

- Server Components fetch data directly with `await`—no useEffect needed
- Use `Promise.all` for parallel fetching to avoid waterfalls
- Next.js deduplicates identical `fetch` requests automatically
- Use React's `cache` for non-fetch data sources
- Throw errors for unexpected failures, return null for expected ones
- Create separate data fetching functions for reusability

## Questions & Answers

### Q: Can I use axios instead of fetch?
**A:** Yes, but you lose Next.js's automatic caching and deduplication. Use fetch with Next.js extensions for best results.

### Q: How do I add headers to all requests?
**A:** Create a wrapper function:
```tsx
async function api(path) {
  return fetch(`${BASE_URL}${path}`, {
    headers: { 'Authorization': `Bearer ${token}` },
  });
}
```

### Q: What about GraphQL?
**A:** Use your preferred GraphQL client. For caching benefits, consider using fetch with GraphQL queries as POST bodies.

### Q: How do I test Server Components with data fetching?
**A:** Mock your data fetching functions. With fetch, you can mock globally or use MSW (Mock Service Worker).

### Q: Can I fetch data in layout.js?
**A:** Yes! Layouts can be async and fetch data. This data is available to all pages within that layout.

## Resources

- [Next.js: Fetching Data](https://nextjs.org/docs/app/building-your-application/data-fetching/fetching)
- [Next.js: Data Fetching Patterns](https://nextjs.org/docs/app/building-your-application/data-fetching/patterns)
- [React: cache](https://react.dev/reference/react/cache)

---

**Next:** [7.2 Caching & Revalidation](./07.2-caching-revalidation.md) - Learn how to control data caching and freshness.
