# Chapter 8.2: Form Handling & Validation

## Overview

Handling forms effectively requires managing loading states, validation errors, and form state. React provides hooks like `useFormStatus` and `useActionState` specifically for Server Actions. This chapter covers these patterns.

## useFormStatus

`useFormStatus` provides the pending state of a parent form. Must be used inside a component that's a child of the form.

```tsx
// components/SubmitButton.tsx
"use client";

import { useFormStatus } from 'react-dom';

export function SubmitButton({ children }) {
  const { pending } = useFormStatus();
  
  return (
    <button type="submit" disabled={pending}>
      {pending ? 'Submitting...' : children}
    </button>
  );
}
```

```tsx
// app/page.tsx
import { SubmitButton } from '@/components/SubmitButton';
import { createPost } from '@/app/actions';

export default function Page() {
  return (
    <form action={createPost}>
      <input name="title" required />
      <textarea name="content" required />
      <SubmitButton>Create Post</SubmitButton>
    </form>
  );
}
```

### useFormStatus Properties

```tsx
const { pending, data, method, action } = useFormStatus();

// pending: boolean - is form submitting?
// data: FormData | null - submitted form data
// method: string - form method (get/post)
// action: function - the action being called
```

### Important: Component Must Be Inside Form

```tsx
// ❌ Wrong: useFormStatus outside form
function Page() {
  const { pending } = useFormStatus();  // Always undefined!
  
  return (
    <form action={action}>
      <button disabled={pending}>Submit</button>
    </form>
  );
}

// ✅ Correct: useFormStatus in child component
function Page() {
  return (
    <form action={action}>
      <SubmitButton />  {/* useFormStatus inside here */}
    </form>
  );
}
```

## useActionState

`useActionState` manages form state across submissions, including errors and previous form data.

```tsx
// components/ContactForm.tsx
"use client";

import { useActionState } from 'react';
import { submitContact } from '@/app/actions';

export function ContactForm() {
  const [state, formAction, isPending] = useActionState(submitContact, null);
  
  return (
    <form action={formAction}>
      <input name="email" defaultValue={state?.email} />
      {state?.errors?.email && (
        <p className="error">{state.errors.email}</p>
      )}
      
      <textarea name="message" defaultValue={state?.message} />
      {state?.errors?.message && (
        <p className="error">{state.errors.message}</p>
      )}
      
      <button disabled={isPending}>
        {isPending ? 'Sending...' : 'Send'}
      </button>
      
      {state?.success && <p className="success">Message sent!</p>}
    </form>
  );
}
```

### Action Must Return State

```tsx
// app/actions.ts
"use server";

export async function submitContact(prevState, formData) {
  const email = formData.get('email');
  const message = formData.get('message');
  
  // Validation
  const errors = {};
  if (!email.includes('@')) {
    errors.email = 'Invalid email address';
  }
  if (message.length < 10) {
    errors.message = 'Message must be at least 10 characters';
  }
  
  if (Object.keys(errors).length > 0) {
    return {
      errors,
      email,
      message,
    };
  }
  
  // Save to database
  await db.contacts.create({ data: { email, message } });
  
  return { success: true };
}
```

## Validation Patterns

### Server-Side Validation with Zod

```tsx
// app/actions.ts
"use server";

import { z } from 'zod';

const UserSchema = z.object({
  name: z.string().min(2, 'Name must be at least 2 characters'),
  email: z.string().email('Invalid email address'),
  age: z.coerce.number().min(18, 'Must be at least 18'),
});

export async function createUser(prevState, formData) {
  const rawData = {
    name: formData.get('name'),
    email: formData.get('email'),
    age: formData.get('age'),
  };
  
  const result = UserSchema.safeParse(rawData);
  
  if (!result.success) {
    return {
      errors: result.error.flatten().fieldErrors,
      data: rawData,
    };
  }
  
  await db.users.create({ data: result.data });
  
  return { success: true };
}
```

### Client-Side Validation (Enhancement)

Add client-side validation for immediate feedback:

```tsx
// components/UserForm.tsx
"use client";

import { useActionState, useState } from 'react';
import { createUser } from '@/app/actions';

export function UserForm() {
  const [state, formAction, isPending] = useActionState(createUser, null);
  const [clientErrors, setClientErrors] = useState({});
  
  const validateField = (name, value) => {
    switch (name) {
      case 'email':
        if (!value.includes('@')) {
          return 'Invalid email';
        }
        break;
      case 'name':
        if (value.length < 2) {
          return 'Name too short';
        }
        break;
    }
    return null;
  };
  
  const handleBlur = (e) => {
    const error = validateField(e.target.name, e.target.value);
    setClientErrors(prev => ({
      ...prev,
      [e.target.name]: error,
    }));
  };
  
  // Combine client and server errors
  const errors = { ...state?.errors, ...clientErrors };
  
  return (
    <form action={formAction}>
      <div>
        <input 
          name="name" 
          onBlur={handleBlur}
          defaultValue={state?.data?.name}
        />
        {errors.name && <span className="error">{errors.name}</span>}
      </div>
      
      <div>
        <input 
          name="email" 
          type="email"
          onBlur={handleBlur}
          defaultValue={state?.data?.email}
        />
        {errors.email && <span className="error">{errors.email}</span>}
      </div>
      
      <button disabled={isPending}>
        {isPending ? 'Creating...' : 'Create User'}
      </button>
    </form>
  );
}
```

## Error Handling

### Returning Errors from Actions

```tsx
// app/actions.ts
"use server";

export async function processPayment(prevState, formData) {
  try {
    const amount = parseFloat(formData.get('amount'));
    const cardNumber = formData.get('cardNumber');
    
    // Validation
    if (isNaN(amount) || amount <= 0) {
      return { error: 'Invalid amount' };
    }
    
    // Process payment
    const result = await paymentProvider.charge({
      amount,
      card: cardNumber,
    });
    
    if (!result.success) {
      return { 
        error: result.message || 'Payment failed',
        code: result.code,
      };
    }
    
    return { success: true, transactionId: result.id };
    
  } catch (error) {
    // Log error server-side
    console.error('Payment error:', error);
    
    // Return user-friendly message
    return { 
      error: 'An unexpected error occurred. Please try again.',
    };
  }
}
```

### Displaying Errors

```tsx
// components/PaymentForm.tsx
"use client";

import { useActionState } from 'react';
import { processPayment } from '@/app/actions';

export function PaymentForm() {
  const [state, formAction, isPending] = useActionState(processPayment, null);
  
  return (
    <form action={formAction}>
      {state?.error && (
        <div className="error-banner">
          <strong>Error:</strong> {state.error}
          {state.code === 'CARD_DECLINED' && (
            <p>Please check your card details or try a different card.</p>
          )}
        </div>
      )}
      
      <input name="amount" type="number" step="0.01" required />
      <input name="cardNumber" required />
      
      <button disabled={isPending}>
        {isPending ? 'Processing...' : 'Pay'}
      </button>
      
      {state?.success && (
        <div className="success-banner">
          Payment successful! Transaction ID: {state.transactionId}
        </div>
      )}
    </form>
  );
}
```

## Examples

### Basic Example: Login Form

```tsx
// app/actions.ts
"use server";

import { cookies } from 'next/headers';
import { redirect } from 'next/navigation';

export async function login(prevState, formData) {
  const email = formData.get('email');
  const password = formData.get('password');
  
  const user = await db.users.findUnique({ where: { email } });
  
  if (!user || !await verifyPassword(password, user.passwordHash)) {
    return { error: 'Invalid email or password' };
  }
  
  // Create session
  const session = await createSession(user.id);
  const cookieStore = await cookies();
  cookieStore.set('session', session.token, {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production',
    maxAge: 60 * 60 * 24 * 7, // 1 week
  });
  
  redirect('/dashboard');
}
```

```tsx
// components/LoginForm.tsx
"use client";

import { useActionState } from 'react';
import { login } from '@/app/actions';
import { SubmitButton } from './SubmitButton';

export function LoginForm() {
  const [state, formAction] = useActionState(login, null);
  
  return (
    <form action={formAction} className="login-form">
      {state?.error && (
        <div className="error">{state.error}</div>
      )}
      
      <input name="email" type="email" placeholder="Email" required />
      <input name="password" type="password" placeholder="Password" required />
      
      <SubmitButton>Log In</SubmitButton>
    </form>
  );
}
```

### Normal Example: Registration with Validation

```tsx
// lib/validations.ts
import { z } from 'zod';

export const RegisterSchema = z.object({
  name: z.string()
    .min(2, 'Name must be at least 2 characters')
    .max(50, 'Name must be less than 50 characters'),
  email: z.string()
    .email('Invalid email address'),
  password: z.string()
    .min(8, 'Password must be at least 8 characters')
    .regex(/[A-Z]/, 'Password must contain an uppercase letter')
    .regex(/[0-9]/, 'Password must contain a number'),
  confirmPassword: z.string(),
}).refine(data => data.password === data.confirmPassword, {
  message: "Passwords don't match",
  path: ['confirmPassword'],
});
```

```tsx
// app/actions.ts
"use server";

import { RegisterSchema } from '@/lib/validations';
import { hash } from 'bcrypt';

export async function register(prevState, formData) {
  const rawData = {
    name: formData.get('name'),
    email: formData.get('email'),
    password: formData.get('password'),
    confirmPassword: formData.get('confirmPassword'),
  };
  
  // Validate
  const result = RegisterSchema.safeParse(rawData);
  
  if (!result.success) {
    return {
      errors: result.error.flatten().fieldErrors,
      data: { name: rawData.name, email: rawData.email },
    };
  }
  
  // Check if email exists
  const existing = await db.users.findUnique({
    where: { email: result.data.email }
  });
  
  if (existing) {
    return {
      errors: { email: ['Email already registered'] },
      data: { name: rawData.name, email: rawData.email },
    };
  }
  
  // Create user
  const passwordHash = await hash(result.data.password, 10);
  await db.users.create({
    data: {
      name: result.data.name,
      email: result.data.email,
      passwordHash,
    }
  });
  
  redirect('/login?registered=true');
}
```

```tsx
// components/RegisterForm.tsx
"use client";

import { useActionState } from 'react';
import { register } from '@/app/actions';

export function RegisterForm() {
  const [state, formAction, isPending] = useActionState(register, null);
  
  return (
    <form action={formAction}>
      <div className="field">
        <label htmlFor="name">Name</label>
        <input 
          id="name"
          name="name" 
          defaultValue={state?.data?.name}
          aria-describedby={state?.errors?.name ? 'name-error' : undefined}
        />
        {state?.errors?.name && (
          <p id="name-error" className="error">{state.errors.name[0]}</p>
        )}
      </div>
      
      <div className="field">
        <label htmlFor="email">Email</label>
        <input 
          id="email"
          name="email" 
          type="email"
          defaultValue={state?.data?.email}
          aria-describedby={state?.errors?.email ? 'email-error' : undefined}
        />
        {state?.errors?.email && (
          <p id="email-error" className="error">{state.errors.email[0]}</p>
        )}
      </div>
      
      <div className="field">
        <label htmlFor="password">Password</label>
        <input 
          id="password"
          name="password" 
          type="password"
          aria-describedby={state?.errors?.password ? 'password-error' : undefined}
        />
        {state?.errors?.password && (
          <p id="password-error" className="error">{state.errors.password[0]}</p>
        )}
      </div>
      
      <div className="field">
        <label htmlFor="confirmPassword">Confirm Password</label>
        <input 
          id="confirmPassword"
          name="confirmPassword" 
          type="password"
          aria-describedby={state?.errors?.confirmPassword ? 'confirm-error' : undefined}
        />
        {state?.errors?.confirmPassword && (
          <p id="confirm-error" className="error">{state.errors.confirmPassword[0]}</p>
        )}
      </div>
      
      <button type="submit" disabled={isPending}>
        {isPending ? 'Creating Account...' : 'Register'}
      </button>
    </form>
  );
}
```

### Complex Example: Multi-Field Form with Dependencies

```tsx
// app/actions.ts
"use server";

export async function createOrder(prevState, formData) {
  const shippingMethod = formData.get('shippingMethod');
  const address = formData.get('address');
  const expressDate = formData.get('expressDate');
  
  const errors = {};
  
  // Conditional validation
  if (shippingMethod === 'express' && !expressDate) {
    errors.expressDate = 'Please select delivery date for express shipping';
  }
  
  if (shippingMethod === 'standard' && !address) {
    errors.address = 'Address is required for standard shipping';
  }
  
  if (Object.keys(errors).length > 0) {
    return { errors };
  }
  
  // Create order...
  return { success: true };
}
```

### Edge Case Example: Form with Array Fields

```tsx
// app/actions.ts
"use server";

export async function saveRecipe(prevState, formData) {
  const name = formData.get('name');
  const ingredients = formData.getAll('ingredients');  // Array
  const steps = formData.getAll('steps');  // Array
  
  // Filter empty entries
  const validIngredients = ingredients.filter(i => i.trim());
  const validSteps = steps.filter(s => s.trim());
  
  if (validIngredients.length < 2) {
    return { 
      errors: { ingredients: 'At least 2 ingredients required' },
      data: { name, ingredients, steps },
    };
  }
  
  await db.recipes.create({
    data: {
      name,
      ingredients: validIngredients,
      steps: validSteps,
    }
  });
  
  return { success: true };
}
```

```tsx
// components/RecipeForm.tsx
"use client";

import { useActionState, useState } from 'react';
import { saveRecipe } from '@/app/actions';

export function RecipeForm() {
  const [state, formAction, isPending] = useActionState(saveRecipe, null);
  const [ingredients, setIngredients] = useState(['', '']);
  
  const addIngredient = () => {
    setIngredients([...ingredients, '']);
  };
  
  const removeIngredient = (index) => {
    setIngredients(ingredients.filter((_, i) => i !== index));
  };
  
  return (
    <form action={formAction}>
      <input name="name" placeholder="Recipe name" required />
      
      <fieldset>
        <legend>Ingredients</legend>
        {ingredients.map((_, index) => (
          <div key={index} className="ingredient-row">
            <input 
              name="ingredients" 
              placeholder={`Ingredient ${index + 1}`}
            />
            {ingredients.length > 2 && (
              <button 
                type="button" 
                onClick={() => removeIngredient(index)}
              >
                Remove
              </button>
            )}
          </div>
        ))}
        <button type="button" onClick={addIngredient}>
          Add Ingredient
        </button>
        {state?.errors?.ingredients && (
          <p className="error">{state.errors.ingredients}</p>
        )}
      </fieldset>
      
      <button type="submit" disabled={isPending}>
        {isPending ? 'Saving...' : 'Save Recipe'}
      </button>
    </form>
  );
}
```

## Key Takeaways

- `useFormStatus` provides pending state (must be in child component)
- `useActionState` manages form state across submissions
- Actions receive `(prevState, formData)` when used with `useActionState`
- Use Zod or similar for server-side validation
- Return errors and previous data from actions
- Combine client and server validation for best UX

## Questions & Answers

### Q: Can I use React Hook Form with Server Actions?
**A:** Yes! React Hook Form works with Server Actions. Use `handleSubmit` to call the action:
```tsx
const onSubmit = handleSubmit(async (data) => {
  const formData = new FormData();
  Object.entries(data).forEach(([key, value]) => formData.append(key, value));
  await action(formData);
});
```

### Q: How do I reset the form after success?
**A:** Use a key to remount the form, or use `useRef` to access the form element:
```tsx
const formRef = useRef();
if (state?.success) formRef.current?.reset();
```

### Q: Why is useFormStatus always false?
**A:** It must be called inside a component that's a child of the form, not the component containing the form.

## Resources

- [React: useFormStatus](https://react.dev/reference/react-dom/hooks/useFormStatus)
- [React: useActionState](https://react.dev/reference/react/useActionState)
- [Zod Documentation](https://zod.dev)

---

**Next:** [8.3 Optimistic Updates](./08.3-optimistic-updates.md) - Make your UI feel instant with optimistic updates.
